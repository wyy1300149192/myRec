# HTML

## 1.如何理解HTML语义化？

- 增加代码可读性
- 利让搜索引擎更容易读懂，利于SEO
- 在没有CSS样式下，也能让内容的结构合理展示

## 2.script标签中defer和async的区别

- `script`：会阻碍HTML解析，下载并执行完脚本才解析HTML
- `async script`：解析HTML过程进行脚本异步下载，下载成功立即执行，执行的时候会阻断HTML解析
- `script defer`：完全不会阻碍HTML解析，解析完成才执行脚本

图示：

![image-20221009160111061](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221009160111061.png)

# CSS



## 1.CSS盒子模型

### 概念

盒子模型，顾名思义，可以装东西的盒子，如`div`，`h`，`li`等。

盒模型分为四个部分：

- 内容 content
- 填充 padding
- 边界 margin
- 边框 border

内容又分为`高`、`宽`。`div`高默认为auto，由子元素决定

### 盒子模型类型

**IE盒模型（border-box）**

属性`width`，`height`包含`content`+`border`+`padding`

![971dd6e8013a474c983d90f67f35aaee_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/971dd6e8013a474c983d90f67f35aaee_tplv-k3u1fbpfcp-zoom-in-crop-mark_3024_0_0_0.webp)



**W3C标准盒模型（content-box）**

属性`width`，`heigth`只包含`content`，不包含`border`和`padding`

### 切换盒模型

修改`CSS3`的`box-sizing`属性即可

```css
// W3C盒模型
box-sizing: content-box

// IE盒模型
box-sizing: border-box
```



### margin负值

- `margin-top` 元素自身会`向上移动`，同时会影响下方的元素向上移动；
- `margin-bottom` 元素`不会位移`，会减少css读取的高度，从而影响下方的元素向上移动。
- `margin-left` 元素会`向左移动`，同时会影响右方的元素向左移动
- `margin-right` 元素自身`不会位移`，会减少css读取的宽度，从而影响右方的元素向左移动



## 2.BFC

> 简单来说就是，`BFC`是一个完全独立的空间（布局环境），让空间里的子元素不会影响到外面的布局。

**怎样触发BFC？**

这里简单列举几个触发`BFC`使用的`CSS`属性

- overflow: hidden
- display: inline-block
- position: absolute
- position: fixed
- display: table-cell
- display: flex

**BFC解决了什么问题？**

`1）外边距重叠塌陷问题：`

​    在两个元素的下外边距和上外边距都设定了值时，会取最大的值设定外边距，而不是加在一起。

​	此时就可以给两个元素触发BFC，即可让两个元素不出现外边距重叠塌陷

`2）清除浮动：`

​	父元素包括子元素的情况下；子元素如果浮动，即可造成父元素的高度塌陷，高度变成0；

​	此时，给父元素触发BFC即可清除浮动，解决父元素高度塌陷的问题

`3）阻止元素被浮动元素覆盖`

​	在两个平级的元素中，如果有一个设置了浮动，将会把另外一个元素覆盖

​	给被覆盖的元素触发BFC，即可让这两个元素独立开，防止覆盖



## 3.圣杯布局和双飞翼布局

**圣杯布局和双飞翼布局的目的：**

- 三栏布局，中间一栏最先加载和渲染（**内容最重要，这就是为什么还需要了解这种布局的原因**）。
- 两侧内容固定，中间内容随着宽度自适应。
- 一般用于 PC 网页。

### 圣杯布局

1）准备结构，中间盒子放第一，优先加载

```html
<div class="container">
  <!-- 中间优先加载，所以放第一 -->
  <div class="center">中间</div>
  <div class="left">左侧</div>
  <div class="right">右侧</div>
</div>
```

2）设置左右内边距，留出左右侧空间

```css
.container {
  /* 给左右留出空间 */
  padding: 0 200px;
  /* 清除浮动：解决塌陷问题 */
  overflow: hidden;
}
```

3）三个盒子左浮动

```css
/* 三个盒子都浮动 */
.container div {
  height: 300px;
  float: left;
}
```

4）中间盒子占满宽度

```css
/* 中间盒子宽度百分百 */
.container .center {
  width: 100%;
  background-color: red;
}
```

5）设置左侧分栏位置

- 先设置左侧-100%左边距，会挪到center的最左侧，此时还是压着center的
- 再设置相对定位左侧移动左内边距的大小即可

```css
.container .left {
  /* 相对定位向左挪200px */
  position: relative;
  left: -200px;
  /* 左侧盒子负百分百左边距 */
  margin-left: -100%;
  width: 200px;
  background-color: aqua;
}
```

6）设置右侧分栏位置

直接右负边距 内边距的大小即可

```css
.container .right {
  width: 200px;
  margin-right: -200px;
  background-color: beige;
}
```

整体代码：

```html
  <style>
    .container {
      /* 给左右留出空间 */
      padding: 0 200px;
      /* 清除浮动：解决塌陷问题 */
      overflow: hidden;
    }

    /* 三个盒子都浮动 */
    .container div {
      height: 300px;
      float: left;
    }

    /* 中间盒子宽度百分百 */
    .container .center {
      width: 100%;
      background-color: red;
    }

    .container .left {
      /* 相对定位向左挪200px */
      position: relative;
      left: -200px;
      /* 左侧盒子负百分百左边距 */
      margin-left: -100%;
      width: 200px;
      background-color: aqua;
    }

    .container .right {
      width: 200px;
      margin-right: -200px;
      background-color: beige;
    }
  </style>
  <body>
    <div class="container">
      <!-- 中间优先加载，所以放第一 -->
      <div class="center">中间</div>
      <div class="left">左侧</div>
      <div class="right">右侧</div>
    </div>
  </body>
```

### 双飞翼布局

1）准备结构

- 需要给中间内容外侧再包一个盒子

```js
 <div class="container">
   <div class="center float">
     <div class="main-wrap">中间</div>
   </div>
   <div class="left float">left</div>
   <div class="right float">right</div>
 </div>
```

2）都左浮动

```css
.container .float {
  height: 300px;
  float: left;
}
```

3）中间大盒子宽度占满

```css
.container .center {
  background-color: red;
  width: 100%;
}
```

4）中间内容区域设置左右外边距

```css
.container .main-wrap {
  margin: 0 200px;
}
```

5）左栏设置中间内容左边距的宽度，左边距-100%

```css
.container .left {
  background-color: aqua;
  width: 200px;
  margin-left: -100%;
}
```

6）右栏设置中间内容右边距的宽度，左边距-200px

```css
.container .right {
  background-color: aquamarine;
  width: 200px;
  margin-left: -200px;
}
```

全部代码：

```html
<style>
  .container .float {
    height: 300px;
    float: left;
  }
  .container .center {
    background-color: red;
    width: 100%;
  }
  .container .main-wrap {
    margin: 0 200px;
  }
  .container .left {
    background-color: aqua;
    width: 200px;
    margin-left: -100%;
  }
  .container .right {
    background-color: aquamarine;
    width: 200px;
    margin-left: -200px;
  }
</style>
<body>
  <div class="container">
    <div class="center float">
      <div class="main-wrap">中间</div>
    </div>
    <div class="left float">left</div>
    <div class="right float">right</div>
  </div>
</body>
```



## 4.水平垂直居中实现方式

1）利用子绝父相，设置left和top各50%。然后再通过translate的y和x各-50%

- ！此方法`不用设置宽高`

```css
.father {
  position: relative;
  background-color: red;
  height: 300px;
}
.son {
  position: absolute;
  background-color: aqua;
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%);
}
```



2）利用子绝父相，设置left、right、top、bottom都设置0，margin设置auto

- ！此方法必须`设置宽高`

```css
.father {
  position: relative;
  background-color: red;
  height: 300px;
}
.son {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  bottom: 0;
  margin: auto;
  background-color: aqua;
  width: 30px;
  height: 30px;
}
```



3）利用子绝父相，设置left和top各50%，再设置margin-left和margin-right各宽高的一半

- ！此方法必须`设置宽高`

```css
.father {
  position: relative;
  background-color: red;
  height: 300px;
}
.son {
  width: 30px;
  height: 30px;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-left: -15px;
  margin-top: -15px;
  background-color: aqua;
}
```

4）利用flex

```css
.father {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 500px;
  background-color: red;
}
.son {
  background-color: aqua;
}
```



## 5.Flex布局

>  弹性盒模型（Flexible Box模型），也被成为flexbox，是一种一维的布局模型（也就是说一次只能处理一个维度上的元素布局，一行或者一列）。它给flexbox的子元素之间提供了强大的空间分布和对齐能力。

### 常用属性

**1）flex-direction**

设置主轴方向，有四个值可选

- row 水平
- row-reverse 水平倒着拍
- column 垂直
- column-reverse 垂直倒着拍



**2）flex-wrap**

设置容器内的元素是否自动换行。默认flex内的元素是不会自动换行的，会压缩成一行显示

- nowrap：不换行，压缩成一行
- wrap：宽度不够自动换行
- wrap-reverse： 宽度不够自动换行，且交叉轴的起始线和终止线会反过来



**3）justify-content**

用来设置容器内元素在主轴方向的对齐方式

- center：居中对齐
- left：左对齐
- right：右对齐
- flex-start：从主轴的开始排列
- flex-end：从主轴的末尾开始排列
- space-between：子元素间隔平均分布，`两端间隔为0`
- space-around：子元素间隔平均分布，两端间隔为元素间隔的`一半`
- space-evenly：子元素、两端间隔`全都`平均分布

**4）align-items**

用来设置容器内的元素在交叉轴(侧轴)的对齐方式

- normal：默认从主轴的开始排列
- flex-start：元素向交叉轴起始线对齐
- flex-end：元素向交叉轴终止线对齐
- start：元素向交叉轴起始线对齐
- end：元素向交叉轴终止线对齐
- center：元素在交叉轴居中。如果元素在交叉轴上的高度大于容器的高度，那么在两个方向上溢出距离相同
- left：元素一个挨着一个对齐在对齐容器的左边。如果属性的轴与内联轴不平行，则该值的行为类似于start。
- right：元素一个挨着一个对齐在对齐容器的右边。如果属性的轴与内联轴不平行，则该值的行为类似于start。

**5）align-content**

align-content属性是设置浏览器如何沿着弹性盒子布局的交叉轴在内容项和周围分配空间

**只适用**多行的flex容器（也就是flex容器中的子项不止一行时该属性才有效果），它的作用是当flex容器在交叉轴上有多余的空间时，将子项作为一个整体（属性值为：flex-start、flex-end、center时）进行对齐



- start: 所有行从容器的起始边缘开始填充

- end: 所有行从容器的结束边缘开始填充

- flex-start: 所有行从垂直轴起点开始填充。第一行的垂直轴起点边和容器的垂直轴起点边对齐。接下来的每一行紧跟前一行

- flex-end: 所有行从垂直轴末尾开始填充。最后一行的垂直轴起点边和容器的垂直轴起点边对齐。所有后续行与前一个对齐

- center: 所有行朝向容器的中心填充。每行互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一行的距离相等于容器的垂直轴终点边和最后一行的距离。

- space-between: 所有行在容器中平均分布。相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的边对齐。

- space-around: 所有行在容器中平均分布，相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的距离是相邻两行间距的一半。

- space-evenly: 所有行沿垂直轴均匀分布在对齐容器内。每对相邻的项之间的间距，主开始边和第一项，以及主结束边和最后一项，都是完全相同的。

## 6.grid布局

> 网格布局（Grid）是最强大的 CSS 布局方案。
>
> 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。

### 容器属性

**`display: grid`指定一个容器采用网格布局。**

```css
div {
  display: grid;
}
```



**`grid-template-columns`定义每一列的列宽**

**`grid-template-rows`定义每一行的行高**

定义三行三列的布局：

```css
.container {
	display: grid;
	grid-template-columns: 40px 40px 40px;
	grid-template-rows: 40px 40px 40px;
}
```

![image-20221019115918339](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221019115918339.png)

除了使用绝对单位，也可以使用百分比。

```css
.container {
  display: grid;
  grid-template-columns: 33.33% 33.33% 33.33%;
  grid-template-rows: 33.33% 33.33% 33.33%;
}
```

**（1）repeat()**

有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用`repeat()`函数，简化重复的值。

`repeat()`接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。

```css
.container {
	display: grid;
	grid-template-columns: repeat(3,50px);
	grid-template-rows: repeat(3,50px)
}
```

重复多个值也是可以的

```css
grid-template-columns: repeat(2, 100px 20px 80px);
```

上面代码定义了6列，重复了两次相同的3列值

![image-20221019120643882](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221019120643882.png)

**（2）auto-fill 关键字**

有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用`auto-fill`关键字表示自动填充。

```css
.container {
  display: grid;
  grid-template-columns: repeat(auto-fill, 100px);
}
```

上面代码表示每列宽度`100px`，然后自动填充，直到容器不能放置更多的列。

![image-20221019121038669](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221019121038669.png)

**（3）fr 关键字**

为了方便表示比例关系，网格布局提供了`fr`关键字（fraction 的缩写，意为"片段"）。如果两列的宽度分别为`1fr`和`2fr`，就表示后者是前者的两倍。

**（4）minmax()**

`minmax()`函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。

```css
grid-template-columns: 1fr 1fr minmax(100px, 1fr);
```

 上面代码中，`minmax(100px, 1fr)`表示列宽不小于`100px`，不大于`1fr`。

**（5）auto 关键字**

`auto`关键字表示由浏览器自己决定长度。

```css
grid-template-columns: 100px auto 100px;
```

**（6）网格线的名称**




# JavaScript

## 变量名规范

- 变量名中能使用的符号：“$”和“_”
- 不能以数字开头

## 

## 1.对象和数据类型之间的关系

### JavaScript有多少种数据类型?

**八种**，分别为 ：

- **Number**
- **String**
- **Boolean**
- **undefined**
- **null**
- **Object**
- **Bigint**
- **Symbol**

### 什么是值类型和引用类型？

**存储位置**

值类型的变量会保存在 **栈内存** 中，如果在一个函数中声明一个值类型的变量，那么这个变量当函数执行结束之后会 **自动销毁**。

引用类型的变量名会保存在 **栈内存** 中，但是变量值会存储在 **堆内存** 中，引用类型的变量不会自动销毁，当没有引用变量引用它时，系统的 **垃圾回收机制** 会回收它。



### **0.1+0.2为什么不等于0.3？** 

JS的四则运算需要先将十进制数 -> 二进制数 -> 再通过二进制运算得到运算结果 -> 再转回十进制 先转为二进制，再进行二进制运算，再转为十进制。所以问题就出在一开始转为二进制的过程中，因为Number使用的是IEEE 754 双精度标准 而在十进制 -> 二进制的过程中，0.1和0.2转换成二进制后会无限循环，又由于JS 采用 IEEE 754 双精度版本表示，在标准位数后面多余的位数会被截段，就会出现**精度丢失**，再通过二进制计算后得到的答案自然不等于0.3。




### 数据类型判断

**typeof运算符**

- 语法：`typeof 数据` 返回一个字符串
- 识别所有值类型
- 识别函数类型
- 识别引用类型，但是无法区分`对象`、`数组`以及`null`



**instanceof方法**

- 语法：`对象 instanceof 引用类型`
- 用来检测引用数据类型，值类型都会返回`false`

判断原理：实例对象的隐式原型 = 构造函数的显式原型



**constructor方法**

- 语法：`数据.constructor === 类型`
- 除了`undefined`和`null`之外，其他类型都可以使用`constructor`方法进行判断



**Object.prototype.toString.call()**

- 所有原始数据类型都是能判断的，还有 **Error 对象，Date 对象**等



**如何判断变量是否为数组？**

```js
Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // "[object Array]"
```



### 数据类型分类

1. **基本数据类型（值类型）**：String字符型，Number数值型，Boolean布尔值，Null空值，Undefined未定义。

2. **引用数据类型（引用类型）**：Object对象

**基本数据类型：**

- 基本数据类型的值是直接保存在**栈内存**中，值与值之间是独立存在的，**修改一个不会影响其他的变量**

**对象：**

- 只要不是基本数据类型，就是对象。

- 对象是保存在堆内存中的，每创建一个对象，就会在**堆内存**开辟一个新的空间，**变量保存的就是一个内存地址**

- **修改一个会影响所有其他引用的此对象的值**

### 注意

实际开发中很容易忽略引用类型的特性，对于引用类型的数据，赋值相当于地址拷贝，a、b指向了同一个堆内存地址。所以改了b，a也会变；本质上a、b就是一个东西。

如果想独立开引用类型的数据，互不影响。可以使用Object.assign()来复制对象

```js
let obj1 = { num: 123 }
let obj2 = Object.assign({}, obj1)
```



## 2.作用域

### 作用域概念

- 通俗讲是变量或函数的`作用范围`，作用域在`函数定义时`，就已经确定了

### 目的

- 为了提高程序的`可靠性`，减少`命名冲突`

### 分类

- `全局作用域`：作用域script标签中，或作用于一个js文件

- `函数作用域（局部作用域）`：作用于函数内部的代码环境

### 全局作用域和`windows对象`

直接写在script标签中的js代码，都属于全局作用域。全局作用域在页面打开时创建，关闭时销毁。

在全局作用域中有一个`全局对象windows`,他代表浏览器的窗口，由浏览器创造，可以直接使用

- 创建的`变量`都会自动保存在windows对象中的`属性`，比如全局作用域有一个`var num = 100`，`num`等同于`windows.num`

- 创建的`函数`会保存在windows对象中的`方法`

### 作用域访问关系

- `内部作用域`可以访问外部作用域
- `外部作用域`无法访问内部作用域

注意：函数作用域在函数定义的时候就已经确定了，所以在其他函数中调用该函数，作用域不变

​	举例：

```js
var a = 1;
function foo() {
    var b = 2;
    console.log(a); //打印结果：1
}
foo();
console.log(b); // 打印结果：Uncaught ReferenceError: b is not defined 没有定义，无法访问内部作用域的变量
```

### 变量的作用域

**全局变量：**

- 在全局作用域下声明的变量，叫`全局变量`。在全局作用域的任何一个地方，都可以访问
- 特殊情况：在函数内不使用 var 声明的变量也是全局变量（不建议这么用）。

**局部变量：**

- 定义在函数作用域的变量，叫`局部变量`。仅限函数内部访问这个变量。
- 函数的`形参`也是属于局部变量。

**执行效率：**

- `全局变量`：只有在浏览器关闭的时候才销毁，比较`占用内存`
- `局部变量`：当其所在的函数执行完毕后销毁，`节省内存`

### 作用域的上下级关系

当一个函数要使用一个变量时，会现在自身作用域寻找（就近原则），如果没有，则会向上一级作用域中寻找，直到最后找到全局作用域，依然没有则报错`ReferenceError`

函数想直接访问`全局作用域`的变量和函数直接可以使用`windows对象`

### 作用域预处理-变量提升

`作用域预处理`的概念：浏览器解析js代码时，会进行一个操作`预处理(预解析)`：将当前js代码中所有变量和函数的定义，放到`当前作用域`代码的最前方

这种预解析也称为`声明提前（变量提升）`

使用`var`关键字声明的变量，会在所有代码执行之前被`声明`（但不会`赋值`），如果不用关键字`var`则不会声明提前（比如使用`let`或`a = 123`直接赋值）

**范例1：**

```js
console.log(a)
var a = 123 // 打印 undefined
```

打印结果不会报错，而是`undefined`，说明`a`被`声明提前了`

**范例2：**

```js
console.log(a)
let a = 123 // 打印 undefined
```

打印结果会报错：`Uncaught ReferenceError: a is not defined`

**范例3：**

```js
foo()
function foo() {
    if(false) {
		var a = 1
    }
    console.log(a) // 打印 undefined
} 
```

打印`undefined` 表示变量`a`在函数执行之前就被`提前声明`了，只是尚未被`赋值`

### 函数的声明提前

不仅在`var`的变量中，使用function创建的函数也会被提前声明，会在所有的代码执行前被创建完成，可以先调用函数，再定义函数

**举例：**

```js
foo() //可以调用函数
function foo() {
    console.log(123) 
}
```

**注意：**

使用`函数表达式`创建的`函数`不会被`声明提前`因为调用该变量时，还是`undefined`

```js
fn(); // 会报错：Uncaught TypeError: fn is not a functio

console.log(fn); // 会打印 undefined

var fn = function foo() {
  console.log(123);
}
```

定义`形参`就相当于在函数作用域中提前声明了变量:

```js
foo(); // 打印 undefined
function foo(e) {
  console.log(e); 
}
```

### 块级作用域

`{}`为`块级作用域`，例如`if语句`中创建的`变量`，只能在`if语句`中使用

在`ES6前`,JavaScript是没有`块级作用域`的概念的

如`var`在`if`中使用，相当于在`全局作用域`与声明了一个变量，在`if`外还是可以使用，很容易造成`变量污染`

**举例：**

```js
if(true) {
    var a = 123
    console.log(a) // 打印 123
}
console.log(a) // 依然可以打印 123
```

在`ES6`中加入了`块级作用域`的`概念`

在块级作用域使用`let`或`const`声明的`变量`将只能在`当前块级作用域使用`,会报错`Uncaught ReferenceError: a is not defined`

**举例**

```js
if (true) {
  let a = 123;
  console.log(a); // 打印 123
}
console.log(a); // 打印 Uncaught ReferenceError: a is not defined
```

## 3.预编译

### JavaScript运行三部曲

脚本执行js引擎都做了什么呢？

1. 语法分析
2. 预编译
3. 解释执行

预编译简单理解就是在内存中开辟一些空间，存放一些变量与函数，预编译确确实实在script代码内执行前发生了
但是它大部分会**发生在函数执行前**

### 预编译流程

```js
<script>
    var a = 1;// 变量声明
    function b(y){//函数声明
        var x = 1;
        console.log('so easy');
    };
    var c = function(){//是变量声明而不是函数声明！！
        //...
    }
    b(100);
</script>

<script>
    var d = 0;
</script>
```

看看引擎对上述代码做了什么吧

- 页面产生便创建了GO全局对象（Global Object），也就是windows对象
- 第一个脚本（script标签）文件加载
- 脚本加载完毕，分析语法是否合法
- 开始预编译
  - 查找变量声明，作为GO属性，值赋予undefined
  - 查找函数声明，作为GO属性，值赋予函数体

```js
//伪代码
GO/window = {
    //页面加载创建GO同时，创建了document、navigator、screen等等属性，此处省略
    a: undefined,
    c: undefined，
    b: function(y){
        var x = 1;
        console.log('so easy');
    }
}
```

- 变量初始化，直到执行到`函数b`

```js
//伪代码
GO/window = {
    //变量随着执行流得到初始化
    a: 1,
    c: function(){
        //...
    },
    b: function(y){
        var x = 1;
        console.log('so easy');
    }
}
```

- 执行到函数b时，又发生了`预编译`
  - 创建AO活动对象（Active Object）
  - 查找形参和变量声明，放到AO中赋予undefined
  - 实参值赋给形参
  - 查找函数声明，值赋予函数体

```js
//伪代码
AO = {
    //创建AO同时，创建了arguments等等属性，此处省略
    y: 100,
    x: undefined
}
```

- 第一个脚本文件执行完成，加载第二个脚本文件
- 第二个脚本文件加载完毕后，进行语法分析
- 语法分析完毕，开始预编译
  - 重复最开始的预编译步骤……

### 总结

**预编译（函数执行前）**

1. 创建AO对象（Active Object）
2. 查找函数的形参和变量声明，形参名和变量作为AO对象的属性，值为undefied
3. 实参赋值给形参
4. 查找函数声明，函数名作为AO对象的属性，值为函数引用（函数本身）

**预编译(脚本代码块script执行前)**

1. 查找全局变量声明（包括隐式全局变量声明，省略var声明），变量名作全局对象的属性，值为undefined
2. 查找函数声明，函数名作为全局对象的属性，值为函数引用

**注意**

- 函数使用let时会直接报错：`Uncaught SyntaxError: Identifier 'a' has already been declared (at demo.html:14:13)`，因为当前作用域已用let声明，无法在let声明前读取形参和函数声明

## 4.this

**概念：**

解析器每次在调用函数时，会向函数内部传递一个隐含的参数，这个参数就是`this`，`this`指向的是一个对象，这个对象我们称为`函数执行的上下文对象`

**函数内的this指向：**

1. 以函数的形式：`this`的指向永远是`window`
1. 以方法的形式调用：`this`指的是调用该`方法的对象`
1. 以构造函数的形式：`this`指的是该构造函数的`实例对象`
1. 以事件绑定函数的形式调用时，`this` 指向`绑定事件的对象`
1. 使用 call 和 apply 调用时，this 指向指定的那个对象

## 5.闭包

**闭包的概念**：在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数当中声明的变量；当调用通过外部函数返回的内部函数时，即使此时外部函数已经执行结束，但是内部函数所引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包

```js
function foo() {
    let a = 1
}
console.log(a) // 此时会报错：Uncaught ReferenceError: a is not defined
```

函数外部只能访问`全局变量`，无法访问函数作用域中的`a`变量，所以会报错

**但在有些场景下，我们需要在`函数外部`访问到`函数作用域`内的`局部变量`，那就可以使用闭包**

如果这个作用域可以访问`另一个函数内部的局部变量`，那就产生了`闭包`，那个作用域所在的函数就称为`闭包函数`



代码举例：

```js
function fn1() {
  let num = 0;
  function fn2() {
    console.log(num);
  }
  fn2()
}
fn1(); // 打印 0
```

上方代码，fn2函数访问了fn1函数中的局部变量。此时fn1中就产生了闭包，fn1就称为闭包函数



闭包可用于延伸变量的作用范围，将调用局部变量的函数返回，供其他作用域使用

```js
function fn1() {
  let num = 0 
  return function fn2() {
    num++
    console.log(num);
  }
}
let num = fn1()
num()
```

**注意事项**

- 闭包函数每调用一次，闭包中的变量将单独存一份，而且不会自动销毁，所以滥用会导致网页的性能问题，在IE可导致内存泄漏，

- 闭包的销毁方法：将闭包所处的变量改变

**在工作中，哪些地方使用到了闭包？**

- 其实在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers 和 任何其他的异步（或同步）任务中，只要使用了回调函数，实际上就是在使用闭包

**为什么要使用闭包？/ 闭包的好处？**

- 保护函数的私有变量不受外部干扰。形成不销毁的栈内存
- 把一些函数内的值保存下来。闭包可以实现方法和属性的私有化

**闭包变量怎么回收呢？**

- 如果是全局变量被作为闭包变量的话，则该闭包变量会一直保存到页面关闭。（因为全局上下文会一直存在，不会被回收，除非页面关闭）
- 如果是局部变量被作为闭包变量的话，下面分两种情况讨论

```scss
-------------------------- 1
function a(){
　　var b= 10;
　　return function(){
　　　　b++;
　　　　console.log(num);
　　}
}
a()(); //11
a()(); //11
复制代码
```

在这段代码中，当a函数执行时，返回的匿名函数中存在对a函数中定义的b变量的引用，但随即匿名函数就被执行，使b++。执行结束后，原本存在的对b的引用已经结束，所以函数a的上下文会被回收，b变量也随之回收。当第二次执行就会重新声明变量b，所以两次输出都是11。

```scss
---------------------- 2
function a(){
    var b = 0;
    return function(){
        b ++;
        console.log(b);
    }
}
var d = a();
d();//1
d();//2
复制代码
```

在这段代码中，函数a的执行结果被赋值给了d，d其实就是返回的匿名函数，也就是说d一直存在对函数a的引用。所以即使d被调用，在整个内存中，依然存在一个变量d，指向匿名函数，并存在对函数a中变量的引用，所以执行两次后，b等于2。




## 6.数组的常见方法

### 数组类型相关方法

| 方法                             | 描述                               | 备注 |
| -------------------------------- | ---------------------------------- | ---- |
| Array.isArray()                  | **判断**是否为数组                 |      |
| toString()                       | 将数组转为**字符串**               |      |
| Array.from(arrayLike)            | 将**伪数组**转为真数组             |      |
| Array.of(value1, value2, value3) | 创建数组：将**一系列值**转换成数组 |      |

### 数组添加与删除

| 方法      | 描述                                                         | 备注           |
| :-------- | :----------------------------------------------------------- | :------------- |
| push()    | 向数组的**最后面**插入一个或多个元素，返回结果为新数组的**长度** | 会改变原数组   |
| pop()     | 删除数组中的**最后一个**元素，返回结果为**被删除的元素**     | 会改变原数组   |
| unshift() | 在数组**最前面**插入一个或多个元素，返回结果为新数组的**长度** | 会改变原数组   |
| shift()   | 删除数组中的**第一个**元素，返回结果为**被删除的元素**       | 会改变原数组   |
| slice()   | 从数组中**提取**指定的一个或多个元素，返回结果为**新的数组** | 不会改变原数组 |
| splice()  | 从数组中**删除**指定的一个或多个元素，返回结果为**被删除元素组成的新数组** | 会改变原数组   |
| fill()    | 填充数组：用固定的值填充数组，返回结果为**新的数组**         | 会改变原数组   |

### 数组的合并与拆分

| 方法     | 描述                                                 | 备注             |
| :------- | :--------------------------------------------------- | :--------------- |
| concat() | 合并数组：连接两个或多个数组，返回结果为**新的数组** | 不会改变原数组   |
| join()   | 将数组转换为字符串，返回结果为**转换后的字符串**     | 不会改变原数组   |
| split()  | 将字符串按照指定的分隔符，组装为数组                 | 不会改变原字符串 |

### 数组排序

| 方法      | 描述                                                    | 备注         |
| :-------- | :------------------------------------------------------ | :----------- |
| reverse() | 反转数组，返回结果为**反转后的数组**                    | 会改变原数组 |
| sort()    | 对数组的元素,默认按照**Unicode 编码**，从小到大进行排序 | 会改变原数组 |

### 查找元素

| 方法                  | 描述                                                         | 备注                                                     |
| :-------------------- | :----------------------------------------------------------- | :------------------------------------------------------- |
| indexOf(value)        | 从前往后索引，检索一个数组中是否含有指定的元素               |                                                          |
| lastIndexOf(value)    | 从后往前索引，检索一个数组中是否含有指定的元素               |                                                          |
| includes(item)        | 数组中是否包含指定的内容                                     |                                                          |
| find(function())      | 找出**第一个**满足「指定条件返回 true」的元素                |                                                          |
| findIndex(function()) | 找出**第一个**满足「指定条件返回 true」的元素的 index        |                                                          |
| every()               | 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true | 全真才为真。要求每一项都返回 true，最终的结果才返回 true |
| some()                | 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true | 一真即真。只要有一项返回 true，最终的结果就返回 true     |

### 遍历数组

|           |                                                              |                                                        |
| :-------- | :----------------------------------------------------------- | :----------------------------------------------------- |
| 方法      | 描述                                                         | 备注                                                   |
| for 循环  | 这个大家都懂                                                 |                                                        |
| forEach() | 和 for 循环类似，但需要**兼容 IE8** 以上                     | forEach() 没有返回值。也就是说，它的返回值是 undefined |
| map()     | 对原数组中的每一项进行加工，将组成**新的数组**               | 不会改变原数组                                         |
| filter()  | 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为**新的数组** | 不会改变原数组                                         |
| reduce    | 接收一个函数作为累加器，返回值是回调函数累计处理的结果       |                                                        |

## 7.字符串的常见方法

| 方法                 | 描述                                                   | 参数                                                         | 备注             |
| :------------------- | :----------------------------------------------------- | ------------------------------------------------------------ | :--------------- |
| indexOf()            | 查找文本，返回查找到的`第一个`下标，未找到返回-1       | `查找的内容，[从指定位置开始查找]`                           | 不会更改原始字符 |
| lastIndexOf()        | 查找文本，返回查找到的`最后一个出现`下标，未找到返回-1 | `查找的内容，[从指定位置开始查找]`                           | 不会更改原始字符 |
| slice()              | `提取字符串`的某个部分，返回提取的字符串               | `起始索引，[终止索引]` ：参数可以是负数，负数从后面开始截取字符串，如果只传一个参数，就是从该参数的索引到最后的全部字符 | 不会更改原始字符 |
| substring()          | 与slice()的方法一样，但是没有办法接受负数              | `起始索引，[终止索引]` :如果只传一个参数，就是从该参数的索引到最后的全部字符 | 不会更改原始字符 |
| substr()             | 与slice()的方法一样                                    | `起始位置，[切割长度]`:参数可以是负数，负数从后面开始截取字符串，如果只传一个参数，就是从该参数的索引到最后的全部字符 | 不会更改原始字符 |
| toUpperCase()        | 把字符串转换成`大写`                                   |                                                              | 不会更改原始字符 |
| toLowerCase()        | 把字符串转化成`小写`                                   |                                                              | 不会更改原始字符 |
| trim()               | 删除字符串两端的`空白符`                               |                                                              | 不会更改原始字符 |
| concat()             | 将`某个字符串拼接其他字符串`                           | `[...其它字符串]`                                            | 不会更改原始字符 |
| charAt()             | 返回`指定下标`的字符                                   | `下标`                                                       | 不会更改原始字符 |
| split()              | 将字符串分割为数组                                     | `[分隔符]`：默认会将整个字符串转成数组                       | 不会更改原始字符 |
| replace()            | 根据条件替换字符内容，返回新字符串                     | `替换条件，替换值`                                           | 不会更改原始字符 |
| statrtsWith,endsWith | 查找是否以指定字符开头，返回布尔值                     | `指定字符`                                                   | 不会更改原始字符 |
| includes             | 查找字符，返回布尔值                                   | `查找项，[开始索引]`                                         | 不会更改原始字符 |
| search               | 查找字符，返回下标                                     | `查找项`                                                     | 不会更改原始字符 |

## 8.面向对象的编程思想

### 面向过程和面向对象

**面向过程：**先分析好具体步骤，然后按照步骤，一步一步解决问题

- 优点：性能比面向对象高，适合与`硬件紧密联系`的东西
- 缺点：`没有`面向对象`易维护`、`易复用`、`易扩展`

**面向对象：**以对象功能划分问题，而不是步骤

- 优点：`易维护、易扩展、易复用`，由于面向对象有封装、继承、多态性的特性，可以设计出`低耦合`的系统，使系统 更加`灵活`、更加`易于维护`
- 缺点：`性能`比面向过程`底`

### 面向对象的编程思想

对代码和数据进行封装，以对象调用的方式，对外提供统一的接口

### 面向对象的特性

在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，适合多人合作的大型软件项目，更符合我们认识事物的规律。

面向对象的特性如下：

- 封装性
- 继承性
- 多态性

## 9.构造函数

### 概念

`构造函数`是一种特殊的函数，用来`创建和初始化对象`，必须和`new`一起使用

### 构造函数和普通函数的区别

- 构造函数习惯`首字母大写`
- `调用方式`不同：普通函数直接调用，构造函数需要使用new关键字调用
- `this的指向`不同：普通函数指向window，构造函数指向实例对象

### new一个构造函数的执行流程

**new执行时，会做以下四件事：**

（1）开辟内存空间，在空间创建一个新的空对象

（2）让this的指向指向创建的新对象

（3）执行构造函数里的代码

（4）自动返回这个新对象

```js
function Demo(name,age) {
    this.name = name
    this.age = age
}

const user = new Demo('张三',18)

console.log(user); // 此处会打印一个对象 {name:'张三',age:'18'}
```

### 实例成员与静态成员

实例成员：构造函数的this上添加的成员

静态成员：构造函数上添加的成员

```js
function Demo(name, age) {
  // 实例成员
  this.name = name;
  this.age = age;
}
// 静态成员
Demo.hobby = "打游戏";

let p1 = new Demo("张三", 18);

// 静态成员只能通过构造函数调用
console.log(Demo.hobby);
console.log(p1.hobby); // 使用实例调用则会打印undefined
console.log(Demo.age); // 相反通过构造函数调用实例成员也会打印undefin
```

**总结：**

1. 实例成员之能通过实例对象访问
2. 静态成员只能通过构造函数本身访问

## 10.对象的基本操作

### 向对象中添加属性

语法：`对象.属性名 = 属性值`

举例：

```js
let obj = new Object();

// 向Obj中添加一个name属性
obj.name = '张三'

// 将 obj 以字符串的方式打印出来
console.log(JSON.stringify(obj)) // 将打印：{ name: '张三' }
```



### 获取和修改对象中的属性

1. `对象.属性名`

   如果获取对象中没有的属性，不会报错，而是会返回`undefined`。

2. `对象['属性名']`

   对象的属性名不强制要求遵守标识符规范，如果确实要是用特殊的属性名，只能通过[]来操作对象中的属性



### 删除对象中的属性

语法：`delete 对象属性`



### in 运算符

通过该运算符可以检查一个对象中是否包含某个属性，有则返回true，没有则返回false

语法： `属性名 in 对象`



### for in 遍历对象

语法：

```js
for (const 变量 in 对象) {

}
```

对象中有几个属性，就会执行几次。每次执行时，会将对象中的每个`属性`的`属性名`赋值给变量



举例：

```js
for (let key in obj) {
	console.log(key) // 这里打印的是对象属性名
	console.log(obj[key]) //这里打印的是每次遍历对应的属性值
}
```



## 11.深拷贝与浅拷贝

### 概念

- 浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用

- 深拷贝：拷贝多层数据；每层级别的数据都会拷贝

  拷贝会把对象里的数据重新复制一份到新的内存控件

### 浅拷贝

方法：使用`Object.assign()`实现浅拷贝

语法：

```js
Object.assign(目标对象,源对象1,源对象2...)
```

### 深拷贝

方法：使用**使用`JSON.stringify()`以及`JSON.parse()`**

语法：

```js
JSON.stringify(目标对象)
JSON.parse(目标对象)
```

## 12.原型与原型链

### 概念

- 原型：一个函数可以看成一个类，原型就是所有类都有的一个属性，原型的作用就是给这个类的一个对象都添加统一的方法
- 原型链：每一个对象都有一个`_proto_`，他指向它的`prototype`原型对象，它的`prototype`原型对象又有一个`_proto_`，指向它的`protoytype`原型对象，就这样层层的向上找，直到最终找到顶级对象`Object`的`prototype`，这个查询路径就是原型链

### 原型的类别

- 显式原型：`protoype`，每一个函数function独有的属性
- 隐式属性：`_proto_`，是每一个对象都具有的属性

### 原型作用

1. 数据共享，节省内存空间
2. 实现继承

### 原型与原型链关系图

- `构造对象`的`隐式原型`就是构造这个对象的函数的`显式原型`
- 当前`函数的原型对象`的隐式原型是`对象原型`
- `Object.prototype`为原型链的`顶级原型`,最终会找到这里
- 当对象或属性获取一个属性时，会沿着原型链一层层寻找下去，如果没有则是`undefined`

![image-20220829160524359](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20220829160524359.png)

## 13.本地存储

### 概念

本地存储就是将某些内容存在用户的电脑上，用`localStorage`和`sessionStorage`两个对象实现

`localStorage`为本地存储

`sessionStorage`为会话存储

两者区别：

- `localStorage`空间大、永久有效、可以跨页面使用
- `sessionStorage`空间小、关闭页面即失效、不能跨页面使用

方法:

- `setItem(key,value)` 存入数据，只能存字符类型数据
- `getItem(key)` 获取数据
- `removeItem(key)` 删除数据
- `clear()` 清除所有数据

## 14.ES6

### 简介

2015年6月，ES6正式发布，ES6实际繁殖ES6及后续的版本

ES6的改进：

- 通过let、const优化了变量提升
- 增加功能：**常量、作用域、对象代理、异步处理、类、继承**等
- 结构赋值、箭头函数、剩余参数、展开语法
- 字符串方法扩展
  - `includes(str)`：判断是否包含指定的字符串
  - `startsWith(str)`：判断是否以指定字符串开头
  - `endsWith(str)`：判断是否以指定字符串结尾
  - `repeat(count)`：重复指定次数
- 数值方法扩展
  - `Number.isFinite(i)`：判断是否为有限大的数。比如`Infinity`这种无穷大的数，返回的就是 false。
  - `Number.isNaN(i)`：判断是否为 NaN。
  - `Number.isInteger(i)`：判断是否为整数。
  - `Number.parseInt(str)`：将字符串转换为对应的数值。
  - `Math.trunc(i)`：去除小数部分。
- 数组方法扩展
  - Array.from()
  - find()
  - findIndex()

## 15.异步编程

### 概念

JavaScript 语言和执行环境是**单线程**。即同一时间，只能处理一个任务。

具体来说，所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个。所有的任务都**需要排队**。

JS 在设计之初，将任务分成了两类：同步任务、异步任务。

### 前端使用异步的场景

什么时候需要**等待**，就什么时候用异步。常见的异步场景如下：

- 1、定时器：setTimeout（定时炸弹）、setInterval（循环执行）
- 2、事件绑定（比如说，按钮绑定点击事件之后，用户爱点不点。我们不可能卡在按钮那里，什么都不做。所以，应该用异步）
- 3、网络请求（含接口请求）：ajax 请求、网络图片加载
- 4、ES6 中的 Promise

现在的大部分软件项目，都是前后端分离的。后端生成接口，前端请求接口。前端发送 ajax 请求，向后端请求数据，然后**等待一段时间**后，才能拿到数据。这个请求过程就是异步任务。



### 事件循环机制

![img](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/20210517_1431.png)

会先进入 Event Table；等时间到了之后，再进入 Event Queue，然后排队（为什么要排队？因为同一时间，JS 只能执行一个任务）。比如说，`setTimeout(()=> {}, 1000)`这种定时器任务，需要等一秒之后再进入 Event Queue。

```js
setTimeout(() => {
    console.log('异步任务');
}, 1000);
```

上面的代码中，等到 1 秒之后，真的会执行异步任务吗？其实不是。

在浏览器中， setTimeout()/ setInterval() 的每调用一次定时器的最小时间间隔是**4毫秒**，这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的 setInterval 的回调函数阻塞导致的。

上面的案例中，异步任务需要等待 1004 毫秒之后，才会从 Event Table 进入到 Event Queue。这在面试中也经常被问到。



此外异步任务还区分**宏任务**和**微任务**

- 宏任务：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering（渲染）

- 微任务：process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)

**node和chrome环境异步任务的执行过程：**

1. 把宏任务放进宏任务队列
2. 把微任务放进微任务队列
3. 查看微任务队列是否为空，为空执行第一个宏任务，不为空执行完所有微任务再执行宏任务

## 16.Ajax

### 概念

Asynchronous Javascript And XML（异步 JavaScript 和 XML）

### 发送Ajax步骤

​	1）创建异步对象，即XMLHttpRequest对象

​	2）使用open方法设置请求参数：method,url,async，方法、url、是否异步(不写默认true)

​	3）发送请求: `send()`

​	4）注册事件：注册onreadystatechange事件，状态改变就调用

​	5）服务端响应，获取返回的数据

### onreadystatechange 事件

注册 onreadystatechange 事件后，每当 readyState 属性改变时，就会调用 onreadystatechange 函数

readyState：（存有 XMLHttpRequest 的状态。从 0 到 4 发生变化）

- 0: 请求未初始化
- 1: 服务器连接已建立
- 2: 请求已接收
- 3: 请求处理中
- 4: 请求已完成，且响应已就绪

status：

- 200: "OK"。
- 404: 未找到页面。

在 onreadystatechange 事件中，**当 readyState 等于 4，且状态码为 200 时，表示响应已就绪**。

### 设置请求头和携带发送数据

```js
xmlhttp.open('POST', 'ajax_test.php', true);

xmlhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');

xmlhttp.send('name=smyhvae&age=27');
```

### 服务器响应的内容

- response：结果
- responseText：获得字符串形式的响应数据。
- responseXML：获得 XML 形式的响应数据。

如果响应的是普通字符串，就使用 responseText；如果响应的是 XML，使用 responseXML。

### 手写Ajax

```js
// 1） 创建XMLHttpRequest对象
let xmlhttp = new XMLHttpRequest();
// 2）设置请求参数
xmlhttp.open("get", "http://ajax-api.itheima.net/api/news");
// 3）发送请求
xmlhttp.send();
// 4）注册事件
xmlhttp.onreadystatechange = function () {
  // 判断请求前状态和响应状态，保证数据完整
  if (xmlhttp.readyState == 4 && xmlhttp.status === 200) {
    console.log(JSON.parse(xmlhttp.response));
  }
};
```

### 封装Ajax

```js
// 封装ajax
const myAjax = function (data, success, fail) {
  var xmlhttp = new XMLHttpRequest();
  const { url, param = "", methods = "get" } = data;
  xmlhttp.open(methods, url);
  xmlhttp.send(param);
  xmlhttp.onreadystatechange = function () {
    if (xmlhttp.readyState == 4 && xmlhttp.status === 200) {
      success && success(JSON.parse(xmlhttp.response));
    } else {
      fail && fail(new Error("请求错误"));
    }
  };
};
myAjax(
  { url: "http://ajax-api.itheima.net/api/new" },
  (res) => {
    console.log(res);
  },
  (err) => {
    console.log(err);
  }
);
```

### 同源和跨域

同源策略是浏览器的安全策略，所谓同源，是指，域名、协议、端口完全相同。

跨域就是不同源访问，处于安全考虑，浏览器不允许ajax跨域获取数据

跨域访问方案：

- iframe：处于安全性考虑，浏览器的开发厂商已经禁止了这种方式。
- JSONP：script 标签的 src 属性传递数据。

## 17.Promise

### 为什么需要Promise？

我们在解决异步场景时，大部分都是使用回调函数来进行

例如我们在发送ajax请求时，需要等待一段时间，等服务器响应后获得结果。如果我们希望在异步结束后执行某个操作，一般就只能通过回调函数进行操作。

所以，为了使回调函数更优雅，ES6语法中，新增了一个名为`Promise`的新规范

### 回调的缺点

- 嵌套过深，会出现回调地狱的问题
- 不同的函数，回调的参数，写法上可能不一致，导致不规范，需要单独记忆

### Promise的介绍和优点

Promise是一个对象，他可以获取异步操作的消息

Promise对象，可以用**同步的表现形式来书写异步代码**

- 可以很好的解决**回调地域**的问题，避免层层嵌套的回调函数。
- 语法简洁，可读性强，便于后期维护。

### 使用步骤

1）通过`new Promise()`构建一个Promise实例。Promise的构造函数传入一个参数，这个参数是一个函数。这个函数用于处理异步任务

2）函数中传入两个参数：`resolve`和`reject`，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数。

3）通过`promise.then()`和`promise.catch()`处理返回的结果

**promise对象的3个状态：**

- 初始化（等待中）：pending
- 成功：fulfilled
- 失败：rejected

当`new Promise()`执行之后，promise对象的状态会被初始化为`pending`，这个状态是初始化状态。`new Promise()`这行代码，括号里的内容是同步执行的，括号里可以再定义一个`异步任务`的`function`，`function`有两个参数：`resolve`和`reject`：

- 成功了执行`resolve()`，此时，`promise`的状态会被自动修改为`fulfilled`
- 失败了执行`reject()`,此时，`promise`的状态会被自动修改为`rejected`

只有`promise`的状态被改变后，才会走到`then`或者`catch`。也就是说，在`new Promise`的时候如果没有写`resolve()`和`reject()`，则`promise.then()`和`promise.catch()`不执行，`promise`的状态一旦改变，就不能再变

并且`resolve()`和`reject()`是可以给`then`和`catch`传参数的

### 利用promise封装ajax请求

```js
// 利用promise封装ajax请求
const promiseAjax = function (params) {
  const xmlhttp = new XMLHttpRequest();
  const { url, param = "", methods = "get" } = params;
  return new Promise((resolve, reject) => {
    xmlhttp.open(methods,url)
    xmlhttp.send(param)
    xmlhttp.onreadystatechange = () => {
      if(xmlhttp.readyState === 4) {
        if(xmlhttp.status >= 200 && xmlhttp.status <= 300) {
          resolve(JSON.parse(xmlhttp.response))
        } else {
          reject(xmlhttp.status)
        }
      }
    }
  });
};

promiseAjax({
  url:'http://ajax-api.itheima.net/api/news'
}).then((res) => {
  console.log(res);
}).catch((err) => {
  console.log(err);
```

### 处理reject错误的两种写法

- 写法1：通过catch方法捕获 状态已经是reject的promise
- 写法2：then可以传两个参数，第一个参数为resolve状态执行，第二个为reject状态执行

写法1：利用catch方法捕获

```js
promiseAjax({
  url: "http://ajax-api.itheima.net/api/news1",
})
  .then((res) => {
    console.log(res);
  })
  // 使用catch方法捕获reject状态的promese
  .catch((err) => {
    console.log(err);
  });
```

写法2：给then方法传两个参数，分别捕获resolve和reject状态的promise

```js
promiseAjax({
  url: "http://ajax-api.itheima.net/api/news1",
}).then(
  // 捕获resolve的promise
  (res) => {
    console.log(res);
  },
  // 捕获reject的promise
  (err) => {
    console.log(err);
  }
);
```

### promise的链式调用

**在工作中，会有很多情况：通过这次接口请求的数据继续发送请求**

**传统链式调用写法：**

```js
// 封装ajax请求
function ajax(url, success, fail) {
  const xmlhttp = new XMLHttpRequest();
  console.log(xmlhttp);
  xmlhttp.open("get", url);
  xmlhttp.send();
  xmlhttp.onreadystatechange = () => {
    if (xmlhttp.readyState === 4) {
      if (xmlhttp.status === 200) {
        success && success(JSON.parse(xmlhttp.response));
      } else {
        fail && fail(new Error("接口错误"));
      }
    }
  };
}
// 执行ajax请求
ajax("http://ajax-api.itheima.net/api/news", (res) => {
  console.log(res.message);
  // 嵌套调用
  ajax("http://ajax-api.itheima.net/api/news1", (res) => {
    console.log(res.message);
    // 嵌套调用
    ajax("http://ajax-api.itheima.net/api/news2", (res) => {
      console.log(res.nessage);
    });
  });
});
```

上面的代码，可读性很差，而且出现了回调地狱问题



**promise链式调用**（初步写法）

```js
// 封装ajax请求
function ajax(url, success, fail) {
  const xmlhttp = new XMLHttpRequest();
  xmlhttp.open("get", url);
  xmlhttp.send();
  xmlhttp.onreadystatechange = () => {
    if (xmlhttp.readyState === 4) {
      if (xmlhttp.status === 200) {
        success && success(JSON.parse(xmlhttp.response));
      } else {
        fail && fail(new Error("接口错误"));
      }
    }
  };
}
// promise处理链式调用
new Promise((resolve,reject) => {
  ajax('http://ajax-api.itheima.net/api/news',(res) => {
    resoleve(res)
  })
})
.then((res) => {
  console.log(res);
  return new Promise((resolve,reject) => {
    ajax('http://ajax-api.itheima.net/api/news1',(res) => {
      resolve(res)
    })
  })
})
.then((res) => {
  console.log(res);
  return new Promise((resolve,reject) => {
    ajax('http://ajax-api.itheima.net/api/news2',(res)=> {
      resove(res)
    })
  })
})
.then((res) => {
  console.log('成功');
})
```

上面代码中，then是可以链式调用的，一旦return一个新的promise实例后，后面的then就可以拿到前面resolve出来的数据

这种扁平化的写法，更方便维护，更好的管理请求成功和失败的状态

上面的代码是初步写法，有不少重复，便于理解。我们也可以对promise进行封装

```js
// 封装ajax请求
function ajax(url, success, fail) {
  const xmlhttp = new XMLHttpRequest();
  xmlhttp.open("get", url);
  xmlhttp.send();
  xmlhttp.onreadystatechange = () => {
    if (xmlhttp.readyState === 4) {
      if (xmlhttp.status === 200) {
        success && success(JSON.parse(xmlhttp.response));
      } else {
        fail && fail(new Error("接口错误"));
      }
    }
  };
}
      
// 封装promise请求
function request(url) {
  return new Promise((resolve, reject) => {
    ajax(url, (res) => {
      if (res) {
        resolve(res);
      } else {
        reject(res);
      }
    });
  });
}
      
// 链式调用promise
request("http://ajax-api.itheima.net/api/news")
  .then((res) => {
    console.log(res);
    return request("http://ajax-api.itheima.net/api/news1");
  })
  .then((res) => {
    console.log(res);
  });
```

上面这段代码更简洁，可读性更强了。**但是如果业务中是不同的接口，处理resolve和reject是不同的，就需要分别封装这些promise实例**



**统一处理reject**：

针对链式请求调用，不管那个请求出错了，希望统一处理。一般在最后写一个catch方法统一处理

```js
getPromise('a.json')
    .then((res) => {
        console.log(res);
        return getPromise('b.json'); // 继续请求 b
    })
    .then((res) => {
        // b 请求成功
        console.log(res);
        return getPromise('c.json'); // 继续请求 c
    })
    .then((res) => {
        // c 请求成功
        console.log('c：success');
    })
    .catch((err) => {
        // 统一处理请求失败
        console.log(err);
    });
```

上面的代码中，由于是统一处理多个请求的异常，所以**只要有一个请求失败了，就会马上走到 catch**，剩下的请求就不会继续执行了。比如说：

- a 请求失败：然后会走到 catch，不执行 b 和 c
- a 请求成功，b 请求失败：然后会走到 catch，不执行 c。



**then里的返回值**

then中的`return`会有两种情况

- 情况1：返回promise。返回的实例对象会调用下一个then
- 情况2：返回普通值。会自动产生一个新的promise实例，来调用下一个then，确保可以继续进行链式调用

### Promise的静态方法与实例方法

**实例方法：**

- `promise.then()`：获取异步任务resolve结果

- `promise.catch()`：获取异步任务reject结果
- `promise.finaly()`：无论是否成功，都会执行



**静态方法：**

直接可以通过`Promise.xxx`调用的方法：

- `Promise.resolve()`
- `Promise.reject()`
- `Promise.all()`
  - 并发处理多个异步任务，所有任务都成功了才会走到`resolve`；只要有一个失败，就马上走到`reject`，整体都算失败
- `Promise.race()`
  - 并发处理多个异步任务，返回的是第一个执行完的promise，且状态和第一个完成的任务状态保持一致
- `Promise.allSettled()`：并发处理多个异步任务，返回所有任务的执行结果（包括成功、失败）。当你有多个彼此不依赖的异步任务执行完成时，或者你想知道每个 promise 的结果时，通常使用它。



**Promise.resolve() 和 Promise.reject()**

某些场景我们没有异步操作，依然想使用`then`获取结果，此时可以使用`Promise.resolve()` 和 `Promise.reject()`包装成 成功和失败的状态

```js
function fn(flag) {
  if(flag) {
    return Promise.resolve('成功')
  } else {
    return Promise.reject('失败')
  }
}
fn(true).then((res) => {
  console.log(res);
})
fn(false).then((err) => {
  console.log(err);
})
script>
```



**Promise.all()**

如果需要同时执行多个异步任务，并且所有任务都成功才算成功，一个失败就会走到`catch`。可以使用`Promise.all([p1,p2,p3])`。

```js
const p2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("2");
  }, 500);
});
const p1 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("1");
  }, 1000);
});
const p3 = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("3");
  }, 200);
});

Promise.all([p1, p2, p3])
  .then((res) => {
    // 三个异步任务按数组顺序执行，将所有resolve返回的结果放在一个数组中返回
    console.log(res);
  })
  // 如果有一个错误直接就会走到这个catch中
  .catch((err) => {
    console.log("失败了" + err);
  });
```

以上代码，三个异步任务按数组顺序执行，将所有`resolve`返回的结果放在一个数组中返回，所以都成功后最后会打印`[1, 2, 3]`

**应用场景**：比如用户同时上传多张图片，需要同时发送多个请求，而且需要在全部上传完成后提示用户，使用`Promise.all`非常灵活



### 宏任务和微任务

执行完`resolve()`之后，就会立刻把`then`中的代码放进微任务队列中，任务的执行顺序是`同步任务 --> 微任务 --> 宏任务`



### 使用promise封装定时器

```js
// 使用promise封装定时器
function timeout(time = 1000) {
  return new Promise((resolve) => setTimeout(resolve, time));
}
timeout(2000)
  .then((res) => {
    console.log("两秒后");
    return timeout();
  })
  .then((res) => {
    console.log("再等一秒后");
  });
```



## 18.async和await

async/await 是 ES8 中引入的新语法，是promise的语法糖。它能实现的效果用then链都能实现，它是为了优化then链开发出来的



**async**

async写在`函数声明的前面`，可以将这个函数变成`async函数`，在async函数中使用`return`，会自动返回一个`fulfilled`状态的`promise`，相当于执行了`Promise.resolve()`

```js
async function fn1() {
  return '你好'
}
      
let result = fn1()
      
console.log(result);
```

以代码上打印：

![image-20220901154758075](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20220901154758075.png)

所以也可以直接通过`then`捕获`你好`这个字符串



**await**

await意为等待，await**只能用于async函数**中，await可以等待一个promise对象或其他值

- 如果是promise对象则返回`promise的结果`
- 如果是其他值则返回该`值本身`

await会停止async函数的执行，`等待promise处理完成`

- 如果promise结果为`错误`，将抛出错误并`停止`async函数后面的执行，成功则继续执行
- 不再使用`then`链式调用，使用`多个await`则可以实现then`链式调用`同样的效果，更加的易用
- await后面的代码立即执行，await下面的代码放到微任务队列



# 浏览器请求相关

## 1.token超时状态码是多少？

  通过调接口时返回的状态码，如果状态码是401（一般情况下），就说明没有携带token，或者token过期了

## 2.HTTP响应的状态码？

1xx：表示目前是协议的中间状态，还需要后续请求

2xx：表示请求成功

3xx：表示重定向状态，需要重新请求

4xx：表示请求报文错误

5xx：服务器端错误

| 状态码 | 类别                             | 分类描述             |
| ------ | -------------------------------- | -------------------- |
| 1XX    | Informational（信息性状态码）    | 请求正在被处理       |
| 2XX    | Success（成功状态码）            | 请求处理成功         |
| 3XX    | Redirection（重定向状态码）      | 需要进行重定向       |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求   |
| 5XX    | Server Error（服务器错误状态吗） | 服务器处理请求时出错 |



## 3.HTTP缓存

### 缓存规则

在客户端进行请求数据时，会查找浏览器的缓存数据是否存在，如果不存在，需要请求服务器，服务器返回后，将数据存储在数据库中

![image-20221009161542553](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221009161542553.png)



### 两种缓存

HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(`强制缓存，对比缓存`)



已存在缓存数据时，仅基于强制缓存，请求数据的流程如下

![image-20221009161814547](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221009161814547.png)



已存在缓存数据时，仅基于对比缓存，请求数据的流程如下

![image-20221009161841595](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221009161841595.png)

我们可以看到两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。
两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。



### 总结

**对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。**



## 4.从URL输入到页面展现到底发生什么？

### 1）DNS域名解析

在浏览器输入网址后，首先进行域名解析，因为浏览器不能直接通过域名找到对应服务器，而是通过IP地址

把`域名解析成IP地址`进行访问

### 2）TCP三次握手

客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口

`（第一次握手，由浏览器发起，告诉服务器我要发送请求了）`

服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息

`（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）`

客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”

`（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）`

### 3）发送HTTP请求

TCP三次握手后，开始发送HTTP请求报文并`识别缓存`

4）服务器处理请求并返回HTTP报文

### 5）浏览器解析并渲染页面

### 6）断开连接：TCP四次握手

- 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。 

  `(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)`



## 5.GET和POST的区别

**GET 请求是用来获取资源的，也就是进行查询操作的，而 POST 请求是用来传输实体对象的，因此会使用 POST 来进行添加、修改和删除等操作**



**缓存不同：**

GET 请求一般会被缓存，比如常见的 CSS、JS、HTML 请求等都会被缓存；而 POST 请求默认是不进行缓存的。



**历史记录不同：**

GET 请求的参数会保存在历史记录中，而 POST 请求的参数不会保留到历史记录中。



## 6.HTTP和HTTPS协议的区别

1、HTTPS协议需要CA证书,费用较高;而HTTP协议不需要
2、HTTP协议是超文本传输协议,信息是明文传输的,HTTPS则是具有安全性的SSL加密传输协议;
3、使用不同的连接方式,端口也不同,HTTP协议端口是80,HTTPS协议端口是443;
4、HTTP协议连接很简单,是无状态的;HTTPS协议是具有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议,比HTTP更加安全



# jQuery

## 特性：

- 即使页面中没有需要操作的元素，jQuery也不会报错。使用原生操作则需要if判断是否有这个操作
- `$()`永远是个对象，如果要通过`$()`判断此元素是否存在需使用`$().length > 0`来判断，或者转化为DOM对象来判断`$()[0]`

## 选择器

### 层次选择器

**选择某个元素后面的元素：**

![image-20221025142124460](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20221025142124460.png)

以上两个选择器可以用其他更简单的方法替代

1. `$(".one").next("div")`
2. `$(".two").nextAll("div")`

**如果需要选择所有同辈的元素可以使用`siblings()`方法：**

```js
// 选取所有#one同辈的div元素
$('#one').siblings("div")
```

> 其他的和`CSS选择器一致`



### 过滤选择器

**基本过滤选择器：**

| 选择器         | 描述                           | 返回 | 示例                                           |
| -------------- | ------------------------------ | ---- | ---------------------------------------------- |
| :first         | 选取第一个元素                 | 单个 | `$('div:first')`选取div中的第一个元素          |
| :last          | 选取最后一个元素               | 单个 | `$('div:last')`选取div中的最后一个元素         |
| :not(selector) | 剔除所有匹配元素               | 集合 | `$("div:not('#app')")`选取div 除了id为`app`的  |
| :even          | 选取从0开始下标为偶数的        | 集合 | `$("div:even")`选取div下标为偶数的             |
| :odd           | 选取从0开始下标为奇数的        | 集合 | `$("div:odd")`选取div下标为奇数的              |
| :eq(index)     | 选取中指定下标的元素           | 单个 | `$("div:eq(1)")`选取div中下标为1的             |
| :gt(index)     | 选取索引大于指定下标的元素     | 集合 | `$("div:gt(3)")`选取div中下标大于3的元素       |
| :lt(index)     | 选取索引小于指定下标的元素     | 集合 | `$("div:gt(3)")`选取div中下标小于3的元素       |
| :header        | 选取所有的`h`标题元素          | 集合 | `$(":header")`选取所有的h标签元素              |
| :animated      | 选取当前正在执行动画的所有元素 | 集合 | `$("div:animated")`选取div中正在执行动画的元素 |
| :focus         | 选取当前获得焦点的元素         | 集合 | `$(":focus")`选取所有获得焦点的元素            |

**可见性过滤选择器：**

| 选择器   | 描述                 | 返回 | 示例                                                         |
| -------- | -------------------- | ---- | ------------------------------------------------------------ |
| :hidden  | 选取所有不可见的元素 | 集合 | `$(':hidden')`选取所有不可见的。包括：type="hidden"、display:none、visibility:hidden等元素 |
| :visible | 选取所有课件的元素   | 集合 | `$(":visible")`选取所有可见的元素                            |

**属性过滤选择器：**

| 选择器    | 描述                     | 返回 | 示例                                  |
| --------- | ------------------------ | ---- | ------------------------------------- |
| [属性]    | 选择拥有此属性的元素     | 集合 | `$('div[id]')`选取div中有id属性的元素 |
| [属性=值] | 选取属性值为指定值的元素 | 集合 | `$("div[]")`选取所有可见的元素        |





# video.js

## 上手

### 引入js与css

```html
<link href="//vjs.zencdn.net/7.10.2/video-js.min.css" rel="stylesheet">
<script src="//vjs.zencdn.net/7.10.2/video.min.js"></script>
```

### 启动video

1）最简单的使用video.js的方式是创建一个video标签，并且包含data-setup属性，这个属性可以包含video.js的各种配置。如果不需要配置，可以穿一个空对象"{}"

页面加载完成后，video.js会找到该video标签，然后启动一个播放器。

```html
<!-- video标签 -->
<video
  id="my-player"
  poster="http://vjs.zencdn.net/v/oceans.png"
  class="video-js"
  controls
  preload="auto"
  data-setup="{}"
>
  <source src="http://vjs.zencdn.net/v/oceans.mp4" type="video/mp4" />
</video>
```



2）js启动，如果不想自启动播放器，可以移除video的data-setup属性使用js代码启动。

```js
let player = videojs("my-player")
```

调用videojs函数的时候，也可以传options配置对象和callback回调函数作为参数。

```js
  let options = {};
  let player = videojs("my-player", options, function onPlayerReady() {
    videojs.log("播放器准备好了");
    this.play();
    this.on("ended", function () {
      videojs.log("播放结束！");
    });
  });
```



## 配置

初始化播放器时，video标签中data-setup属性中的对象可以设置初始化的一些配置信息。或在js代码中：videojs函数中第二个对象参数中设置配置信息。

可用配置如下：

### autoplay

Type:boolean|string

注意：

1. 浏览器对autoplay支持情况不同，即使配置了autoplay也可能不生效
2. 如果在video标签配置了autoplay属性，则会忽略从options中传入的autoplay值
3. 字符串类型的值，只能通过options传

可取值：

- 布尔类型 false ，等同于 video 标签上没有 autoplay 属性。表示不用自动播放
- 布尔类型 true ，等同于在video标签上添加了autoplay 属性，表示需要自动播放
- 字符串类型 ‘muted’, 将会把播放器设置成静音，然后调用play() 实现自动播放
- 字符串类型 ‘play’, 将会调用play()实现自动播放。
- 字符串类型 ‘any’, 将会调用play实现自动播放，如果不能播放，则会把播放器设置成静音状态，再调用play()

### controls

Type: boolean

视频控制栏，默认true，设置为false可以隐藏控制条

### height

Type: string|number

播放器高，单位px

### width

Type: string|number

播放器宽，单位px

### loop

Type: boolean

循环播放

### muted

Type: boolean

静音

### poster

Type: string

封面，值为图片的url

### preload

Type: string

提前下载，用于告诉浏览器，当video标签加载后，是否需要立即下载视频资源

可取值：

- 'auto' 立即下载视频资源（如果浏览器支持的话），有些手机浏览器节省带宽，会提前禁止下载。
- 'metadata' 只下载视频的meta数据，meta数据包含视频的时长和大小，有时候是通过下载几帧视频数据来得到meta的相关信息。
- 'none' 不用提前下载任何数据，只有用户点击播放后才开始下载数据

### src

Type: string

视频的url链接

### aspectRatio

Type: string

宽高比，设置aspectRatio后，播放器将不是固定大小的值，播放器大小会根据aspectRatio的值动态计算得到。aspectRatio的值为一个比例，如'4:3'或'16:9'。

也可以通过给video标签设置特定的class，如vjs-16-9,vjs-9-16,vjs-4-3来实现同样的效果。

注意：

1. 设置此属性将会导致width和height失效

### autoSetup

Type: boolean

是否允许使用video的data-setup属性启动播放器。

注意：

1. 必须在加载 videojs 时使用 videojs.options.autoSetup = false 全局设置才能生效。

```js
// 引入video.js相关的js和css
import videojs from 'video.js'
import "video.js/dist/video-js.min.css"
// 设置autoSetup
videojs.options.autoSetup = false
```

### fluid

Type: boolean

设置为true，播放器大小将不是一个固定的值，它会根据宽高比（aspectRatio）动态计算出来，以适应其容器的大小。

如果video标签class有vjs-fluid，那么fluid会自动被设置成true。

注意：

1. 设置此属性将会导致width和height失效

### inactivityTimeout

Type: number

当播放器处于活动状态，播放器会存在一个类名`vjs-user-active`。如果长时间对播放器无操作的话，播放器就会进入非活动状态，播放器会删除`vjs-user-activ`类名，添加一个类名`vjs-user-inactive`

inactivityTimeout就是用来定义多少毫秒用户不操作，播放器将进入非活动状态。如果设置值为0，表示播放器永远不会进入非活动状态。

可以通过监听`useractive`来判断播放器是否进入活动状态。

### language

Type: string 

默认: 浏览器语言 or ‘en’

用来设置初始化播放器时，使用的语言。播放器可以使用那些语言可以在**dist/lang**文件夹查看

### language

定义哪些语言可以在播放器中使用，Object的key为(language code)[https://www.iana.org/assignments/language-subtag-registry/language-subtag-registry]，值为一个对象（对象的key为英语，值为翻译）。

> 通常我们不会在options中使用languages属性，而是使用videojs.addLanguage()这个函数。









# Swiper库

## 下载Swiper

地址：[下载Swiper - Swiper中文网](https://swiper.com.cn/download/index.html#file1)

## Swiper使用

1. 首先加载插件，需要用到的文件有swiper-bundle.min.js和swiper-bundle.min.css文件，不同[Swiper版本](https://swiper.com.cn/about/us/index.html#version-different)用到的文件名略有不同。

```html
<!DOCTYPE html>
<html>
<head>
    ...
    <link rel="stylesheet" href="dist/css/swiper-bundle.min.css">
</head>
<body>
    ...
    <script src="dist/js/swiper-bundle.min.js"></script>
    ...
</body>
</html>
```

2.添加HTML内容。Swiper7的默认容器是'.swiper'，Swiper6之前是'.swiper-container'。

导航等组件可以放在Swiper容器之外

```html
<div class="swiper">
    <div class="swiper-wrapper">
        <div class="swiper-slide">Slide 1</div>
        <div class="swiper-slide">Slide 2</div>
        <div class="swiper-slide">Slide 3</div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>
    
    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
    
    <!-- 如果需要滚动条 -->
    <div class="swiper-scrollbar"></div>
</div>

```

3.你可能想要给Swiper定义一个大小，当然不要也行。

```css
.swiper {
    width: 600px;
    height: 300px;
}  
```

4.初始化Swiper。

```html
<script>        
  var mySwiper = new Swiper ('.swiper', {
    direction: 'vertical', // 垂直切换选项
    loop: true, // 循环模式选项
    
    // 如果需要分页器
    pagination: {
      el: '.swiper-pagination',
    },
    
    // 如果需要前进后退按钮
    navigation: {
      nextEl: '.swiper-button-next',
      prevEl: '.swiper-button-prev',
    },
    
    // 如果需要滚动条
    scrollbar: {
      el: '.swiper-scrollbar',
    },
  })        
  </script>
```

如果作为CommonJs 或ES 模块引入

```js
//CommonJs
let Swiper = require('swiper');    
let mySwiper = new Swiper('.swiper', { /* ... */ });

//ES
import Swiper from 'swiper';    
let mySwiper = new Swiper('.swiper', { /* ... */ });
```



## API



# Vue2

## vue/cli 脚手架工具

1. 安装脚手架和创建项目
   - 安装@vue/cli 脚手架工具：`npm i @vue/cli -g `
   - 创建 vue 项目：`vue create 名字`
## Vue 实例创建
```
var vm = new Vue({
  // 选项
})
```
## Vue 实例中的选项
`介绍 vue 实例中的配置`

### data
`vue数据对象`，vue 实例初始化时将 data 对象中的数据挂载在 vue 实例中，值发生改变时，模板也会匹配最新的值

### methods
`方法`methods 用于放置 js 方法

### computed
`计算属性`computed 中用于定义计算属性，本意是计算复杂的逻辑运算，与 medhods 相比，computed 对他的响应式依赖进行**缓存**，只有相关依赖发生变化才会重新调用

**完整写法**：考虑读取与修改值

```js
computed:{
    属性:{
    get(){return 属性值}
    set(value){修改执行}
    }
}
```
**简写**：只考虑读取
```js
 Compouted:{
    属性(){
        return 属性值
    }
}
```
### watch
`监视属性`**检测属性是否发生变化，发生变化则执行，也可用于获取属性变化的值**
- data: 监视的属性
- handler:监视属性发生改变时调用
- newValue:新的值
- oldValue:旧的值
  **完整写法**
  ```js
  watch:{
      data:{
  	     //配置
           handler(newValue,oldValue){
              //执行
          }
      }
  }
  ```
  **简写**：没有配置的情况下
  ```js
  watch:{
      data(newValue,oldValue){
              //执行
      }
  }
  ```
  **watch 中的常用配置**

| 配置项    | 默认值 | 值类型 | 说明                                                                                                                       |
| --------- | ------ | ------ | -------------------------------------------------------------------------------------------------------------------------- |
| handler   |        | 函数   | 监视属性发生改变时调用                                                                                                     |
| deep      | false  | 布尔   | 使 watch 深度监视：watch 默认只能检测第一级默认的数据变化，此属性将使 watch 可以检测多级数据的变化（深度监视无法获得旧值） |
| immediate | false  | 布尔   | 初始化时就让 handler 调用一次                                                                                              |
### filters

`过滤器` 用于处理简单的逻辑运算 `!vue3已弃用`

在模板中定义过滤器 `{{data | filtersName | filtersName2 }}`

- filtersNanme 是一个`函数`，需`返回`一个值

- filtersNanme 有两个`形参`

  1. data

  1. 函数形参

- `第二个过滤器`的第一个形参接收上一个过滤器的值，以此类推

**使用过滤器处理时间格式化**

```html
<body>
  <div class="box">
    <h2>现在的时间是：{{time | timeFormData }}</h2>
    <h2>现在的时间是：{{time | timeFormData("YYYY-MM-DD") }}</h2>
    <h2>现在的时间是：{{time | timeFormData | time2}}</h2>
  </div>
  <script>
    new Vue({
      el: ".box",
      data: {
        time: new Date(),
      },
      filters: {
        timeFormData(val, str = "YYYY-MM-DD HH:mm:ss") {
          return dayjs(val).format(str);
        },
        time2(val) {
          return val.slice(0, 4);
        },
      },
    });
  </script>
</body>
```

### directives

`自定义指令`用于开发者 自定义设定 操作 DOM 元素

**用法**
1. 模板标签定义`v-自定义指令`
2. directives 对象定义自定义指令函数，接收两个参数`el`:指令绑定的 dom `binding`：一个对象，可以获得 value

**什么时候会调用自定义指令函数？**

1. 初始化时
2. 指令所在的模板被重新解析时

**如果需要在特定的时间调用函数，将自定义指令写成`对象`，有以下几个钩子函数**

1. `bind() ` 指令与元素绑定时，一上来
2. `inserted() `指令所在元素插入到页面时
3. `updata() ` 指令所在模板重新解析时 4

## Vue 文件结构

vue 文件中有三个标签

1. `template` 对应 vue 模板
2. `script` 对应 js 语句
3. `style` 对应 css 样式

## 常用指令

| **指令**                   | **说明**                                                     | **语法**                        | **备注**                                                     | **书写位置**                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------- | ------------------------------------------------------------ | ------------------------------------ |
| **v-bind**                 | 绑定参数，使用v-bind指令可响应式的更新html：                 | v-bind:属性:"变量"              | **简写：** :属性:"变量'                                      | 标签属性                             |
| **v-on**                   | 利用v-on绑定js监听事件                                       | v-on:事件名 = "methods里的方法" | **简写：**@事件名 = "methods里的方法"                        | 标签属性                             |
| **v-model**                | 参数的双向数据绑定，让value和变量互相绑定                    | v-model="变量"                  |                                                              | `<input>、<textarea>`  及 `<select>` |
| **v-html**      **v-text** | 相当于innerHtml和innerText，会覆盖插值表达式                 | v-html与v-text                  | **严重注意：**v-html在网站上动态渲染html是非常危险的，永远不要用在用户提交的内容上 | 标签属性                             |
| **v-show**                 | 是否隐藏元素，相当于display:none，true为显示，false为隐藏    | v-show = "变量"                 |                                                              | 标签属性                             |
| **v-if**                   | 条件为true则显示，否则隐藏,直接在页面中删除dom，可以配合v-else-if或v-else使用,中间不能被打断 | v-if="条件"                     |                                                              | 标签属性                             |
| **v-for**                  | 根据数组元素渲染一个列表                                     | v-for = "(元素,下标) in 源数组" | 遍历对象的话，两个形参为属性值和属性名    遍历时key默认是index | 标签属性                             |
| **:class**                 | 绑定class({}中均可使用变量)                                  | :class = "{类名:布尔值,…}"      |                                                              | 标签属性                             |
| **:style**                 | 绑定style({}中均可使用变量)                                  | :style= "{css属性:值,…}"        |                                                              | 标签属性                             |
| v-cloak                    | vue实例接管容器后，会删掉此属性，在实例接管之前，配合css的display：none解决html直接显示在页面的问题 | v-cloak                         |                                                              | 标签属性                             |
| v-once                     | 使所在标签的插值属性初次动态渲染后，变为静态，以后数据更新，不会影响v-once所在的标签的更新 | v-once                          |                                                              | 标签属性                             |
| v-pre                      | 跳过加了v-pre标签的vue编译过程，为不需要编译的标签跳过，节省性能 | v-pre                           |                                                              | 标签属性                             |
| ref                        | 给DOM元素起名字，方便vue操作dom元素                          | ref="name"                      | 如果放在组件标签上，得到的会是一个组件实例对象               | 标签属性                             |
| $refs                      | 获取标签属性有ref的dom节点                                   |                                 |                                                              | 组件内对象                           |

## 数据代理

![4234234234234](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/4234234234234.png)

## 组件实例原理

![1231231242435234](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/1231231242435234.png)

## 插槽

- **基本使用：**子组件**slot**标签**可以接收父组件中**组件标签中的内容
- **具名插槽：**如子组件需要有多个slot标签传输不同的内容:
  1. **slot**标签加**name属性**命名
  2. 在父组件的组件标签中使用**`<template v-solt:name>`**设置各个slot标签内容
- **作用域插槽：**主组件的组件标签需要用到子组件的属性
  1. 子组件slot标签：`<slot :名称="值">`
  2. 子组件根据定义名称和值**生成对象**
  3. 主组件template标签中`v-slot="自定名称"`(此会收到子组件传来的对象{名称:'值'})

## 生命周期

![](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E5%9B%BE%E7%89%87.png)



# Vue3

## Vue3 介绍

**vue3.0 正式版 于 2020年 9月18日 发布**

1. **性能提升**

   - 渲染速度快 55%，更新渲染快 133%

   * 打包大小减少 41%

   * 内存减少 54%

2. **源码提升**

   - **使用 Proxy 实现响应式**

   * 重写虚拟 DOM

3. **更好支持 TS**

4. **新特性**
   
   - **组合式API Composition API ()**

## 新生命周期图示

## 组合式API

> 当项目变大时 在处理vue2的单个逻辑时，需要跳转好几个地方找相关代码，非常麻烦
>
> 所以，组合式API可将单个逻辑收集在一起便于维护

### **`setup`组件选项**

新的 `setup` 选项在**组件被创建之前**执行，是一个接收`props` 和 `context`的函数，`setup`可以返回一个对象，将对象中的数据暴露出来，可供模板使用

**注意**：在 `setup` 中你应该避免使用 `this`，因为它不会找到组件实例

### `ref`响应式变量

在 Vue3.0 中，我们可以通过一个`ref函数`设置响应式变量

```js
import { ref } from 'vue'

const num = ref(1)
```

ref接受参数，并将包裹在一个带有value的对象返回，然后可以通过此对象访问或更改值

```js
import { ref } from 'vue'

const num = ref(1)

console.log(num.value) // 1
```

### 生命周期钩子

setup中的生命周期钩子名称在选项式的名称加上前缀为`on`，如`onMounted`

钩子函数接受一个回调，当钩子函数被组件调用时，该回调将被执行

```js
import { onMounted } from 'vue'

setup() {
    onMounted(() => {
        console.log('onMounted') // 在mounted时打印'onMounted'
    })
}
```

### watch

**setup中的watch接受三个参数**

- 监视的属性
- 回调函数
- 可选配置选项

**范例**

```js
import { watch } from 'vue'

const num = ref(0)
watch(num, (newValue,oldValue) => {
    console.log('新值为' + oldValue)
})
```

### computed

和钩子函数类似，接受一个回调函数在依赖属性发生变化执行回调

```js
import { computed } from 'vue'
const num = ref(0)

const sum = computed(() => num + 100)

num.value++
console.log(sum) // 101
```



## Provide / Inject

> 对于深度嵌套的传递数据，使用props需要逐级传递，会很麻烦
>
> 这种情况，使用一对provide和inject，无论层级有多深，父组件可以给所有下级组件传递数据

父组件使用provide提供数据

子组件使用inject使用这些数据

# Router

## 基本使用

### JavaScript

```js
// 1. 定义路由组件.
// 也可以从其他文件导入
const Home = { template: '<div>Home</div>' }
const About = { template: '<div>About</div>' }

// 2. 定义一些路由
// 每个路由都需要映射到一个组件。
// 我们后面再讨论嵌套路由。
const routes = [
  { path: '/', component: Home },
  { path: '/about', component: About },
]

// 3. 创建路由实例并传递 `routes` 配置
// 你可以在这里输入更多的配置，但我们在这里
// 暂时保持简单
const router = VueRouter.createRouter({
  // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。
  history: VueRouter.createWebHashHistory(),
  routes, // `routes: routes` 的缩写
})

// 5. 创建并挂载根实例
const app = Vue.createApp({})
//确保 _use_ 路由实例使
//整个应用支持路由。
app.use(router)

app.mount('#app')

// 现在，应用已经启动了！
```

### HTML

```vue
<script src="https://unpkg.com/vue@3"></script>
<script src="https://unpkg.com/vue-router@4"></script>

<div id="app">
  <h1>Hello App!</h1>
  <p>
    <!--使用 router-link 组件进行导航 -->
    <!--通过传递 `to` 来指定链接 -->
    <!--`<router-link>` 将呈现一个带有正确 `href` 属性的 `<a>` 标签-->
    <router-link to="/">Go to Home</router-link>
    <router-link to="/about">Go to About</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
```

## 重定向

重定向也是通过 `routes` 配置来完成，下面例子是从 `/home` 重定向到 `/`：

```js
const routes = [{ path: '/home', redirect: '/' }]
```

重定向的目标也可以是一个命名的路由：

```js
const routes = [{ path: '/home', redirect: { name: 'homepage' } }]
```

## 别名

**将 `/` 别名为 `/home`，意味着当用户访问 `/home` 时，URL 仍然是 `/home`，但会被匹配为用户正在访问 `/`**

```js
const routes = [{ path: '/', component: Homepage, alias: '/home' }]
```

## 导航守卫

# uni-app

## 个人小程序id

wx9e42ad509166a506

## 介绍

可以在三端同时兼容：

- web
- 手机端
- 小程序

## 运行

第一次运行需要设置微信开发者工具：设置-安全设置-服务端口：打开

否则会报错：

![image-20220920110132740](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20220920110132740.png)

## 页面配置

### 通过globalStyle进行全局配置

`@/pages.json的globalStyle对象配置`

| 属性                         | 类型     | 默认值  | 描述                                                         | 平台差异说明                                     |
| :--------------------------- | :------- | :------ | :----------------------------------------------------------- | :----------------------------------------------- |
| navigationBarBackgroundColor | HexColor | #F7F7F7 | 导航栏背景颜色（同状态栏背景色）                             | APP与H5为#F7F7F7，小程序平台请参考相应小程序文档 |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色及状态栏前景颜色，仅支持 black/white           |                                                  |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |                                                  |
| navigationStyle              | String   | default | 导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏，需看[使用注意](https://uniapp.dcloud.net.cn/collocation/pages#customnav) | 微信小程序 7.0+、百度小程序、H5、App（2.0.3+）   |
| backgroundColor              | HexColor | #ffffff | 下拉显示出来的窗口的背景色                                   | 微信小程序                                       |
| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 dark / light                     | 微信小程序                                       |
| enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新，详见[页面生命周期](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle)。 |                                                  |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见[页面生命周期](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle) |                                                  |
| backgroundColorTop           | HexColor | #ffffff | 顶部窗口的背景色（bounce回弹区域）                           | 仅 iOS 平台                                      |
| backgroundColorBottom        | HexColor | #ffffff | 底部窗口的背景色（bounce回弹区域）                           | 仅 iOS 平台                                      |

### pages注册页面

需要在`pages.json`的pages数组添加新建的页面

- `pages`数组中第一项表示应用启动页

创建了message页面并设置为启动页：

```json
"pages": [ //pages数组中第一项表示应用启动页
	{
		"path": "pages/index/message",
		"style": {
			"navigationBarTitleText": "信息"
		}
	},
	{
		"path": "pages/index/index",
		"style": {
			"navigationBarTitleText": "我的app"
		}
	}
],
```

pages数组中对象style的配置：

用于设置每个页面的状态栏、导航条、标题、窗口背景色等。

页面中配置项会覆盖 [globalStyle](https://uniapp.dcloud.net.cn/collocation/pages#globalstyle) 中相同的配置项

| 属性                         | 类型     | 默认值  | 描述                                                         | 平台差异说明                                                 |
| :--------------------------- | :------- | :------ | :----------------------------------------------------------- | :----------------------------------------------------------- |
| navigationBarBackgroundColor | HexColor | #000000 | 导航栏背景颜色（同状态栏背景色），如"#000000"                |                                                              |
| navigationBarTextStyle       | String   | white   | 导航栏标题颜色及状态栏前景颜色，仅支持 black/white           |                                                              |
| navigationBarTitleText       | String   |         | 导航栏标题文字内容                                           |                                                              |
| navigationBarShadow          | Object   |         | 导航栏阴影，配置参考下方 [导航栏阴影](https://uniapp.dcloud.net.cn/collocation/pages#navigationBarShadow) |                                                              |
| navigationStyle              | String   | default | 导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏，需看[使用注意](https://uniapp.dcloud.net.cn/collocation/pages#customnav) | 微信小程序 7.0+、百度小程序、H5、App（2.0.3+）               |
| disableScroll                | Boolean  | false   | 设置为 true 则页面整体不能上下滚动（bounce效果），只在页面配置中有效，在globalStyle中设置无效 | 微信小程序（iOS）、百度小程序（iOS）                         |
| backgroundColor              | HexColor | #ffffff | 窗口的背景色                                                 | 微信小程序、百度小程序、字节跳动小程序、飞书小程序、京东小程序 |
| backgroundTextStyle          | String   | dark    | 下拉 loading 的样式，仅支持 dark/light                       |                                                              |
| enablePullDownRefresh        | Boolean  | false   | 是否开启下拉刷新，详见[页面生命周期](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle)。 |                                                              |
| onReachBottomDistance        | Number   | 50      | 页面上拉触底事件触发时距页面底部距离，单位只支持px，详见[页面生命周期](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle) |                                                              |
| backgroundColorTop           | HexColor | #ffffff | 顶部窗口的背景色（bounce回弹区域）                           | 仅 iOS 平台                                                  |
| backgroundColorBottom        | HexColor | #ffffff | 底部窗口的背景色（bounce回弹区域）                           | 仅 iOS 平台                                                  |
| disableSwipeBack             | Boolean  | false   | 是否禁用滑动返回                                             | App-iOS（3.4.0+）                                            |
| titleImage                   | String   |         | 导航栏图片地址（替换当前文字标题），支付宝小程序内必须使用https的图片链接地址 | 支付宝小程序、H5                                             |
| transparentTitle             | String   | none    | 导航栏透明设置。支持 always 一直透明 / auto 滑动自适应 / none 不透明 | 支付宝小程序、H5、APP                                        |
| titlePenetrate               | String   | NO      | 导航栏点击穿透                                               | 支付宝小程序、H5                                             |
| app-plus                     | Object   |         | 设置编译到 App 平台的特定样式，配置项参考下方 [app-plus](https://uniapp.dcloud.net.cn/collocation/pages#app-plus) | App                                                          |
| h5                           | Object   |         | 设置编译到 H5 平台的特定样式，配置项参考下方 [H5](https://uniapp.dcloud.net.cn/collocation/pages#h5) | H5                                                           |
| mp-alipay                    | Object   |         | 设置编译到 mp-alipay 平台的特定样式，配置项参考下方 [MP-ALIPAY](https://uniapp.dcloud.net.cn/collocation/pages#mp-alipay) | 支付宝小程序                                                 |
| mp-weixin                    | Object   |         | 设置编译到 mp-weixin 平台的特定样式                          | 微信小程序                                                   |
| mp-baidu                     | Object   |         | 设置编译到 mp-baidu 平台的特定样式                           | 百度小程序                                                   |
| mp-toutiao                   | Object   |         | 设置编译到 mp-toutiao 平台的特定样式                         | 字节跳动小程序                                               |
| mp-lark                      | Object   |         | 设置编译到 mp-lark 平台的特定样式                            | 飞书小程序                                                   |
| mp-qq                        | Object   |         | 设置编译到 mp-qq 平台的特定样式                              | QQ小程序                                                     |
| mp-kuaishou                  | Object   |         | 设置编译到 mp-kuaishou 平台的特定样式                        | 快手小程序                                                   |
| mp-jd                        | Object   |         | 设置编译到 mp-jd 平台的特定样式                              | 京东小程序                                                   |
| usingComponents              | Object   |         | 引用小程序组件，参考 [小程序组件](https://uniapp.dcloud.net.cn/tutorial/miniprogram-subject.html#小程序自定义组件支持) | App、微信小程序、支付宝小程序、百度小程序、京东小程序        |
| leftWindow                   | Boolean  | true    | 当存在 leftWindow时，当前页面是否显示 leftWindow             | H5                                                           |
| topWindow                    | Boolean  | true    | 当存在 topWindow 时，当前页面是否显示 topWindow              | H5                                                           |
| rightWindow                  | Boolean  | true    | 当存在 rightWindow时，当前页面是否显示 rightWindow           | H5                                                           |
| maxWidth                     | Number   |         | 单位px，当浏览器可见区域宽度大于maxWidth时，两侧留白，当小于等于maxWidth时，页面铺满；不同页面支持配置不同的maxWidth；maxWidth = leftWindow(可选)+page(页面主体)+rightWindow(可选) | H5（2.9.9+）                                                 |

### tabBar

- 当设置 position 为 top 时，将不会显示 icon
- tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。
- tabbar 切换第一次加载时可能渲染不及时，可以在每个tabbar页面的onLoad生命周期里先弹出一个等待雪花（hello uni-app使用了此方式）
- tabbar 的页面展现过一次后就保留在内存中，再次切换 tabbar 页面，只会触发每个页面的onShow，不会再触发onLoad。
- 顶部的 tabbar 目前仅微信小程序上支持。需要用到顶部选项卡的话，建议不使用 tabbar 的顶部设置，而是自己做顶部选项卡，可参考 hello uni-app->模板->顶部选项卡。

**属性说明：**

| 属性            | 类型     | 必填 | 默认值 | 描述                                                         | 平台差异说明                                         |
| :-------------- | :------- | :--- | :----- | :----------------------------------------------------------- | :--------------------------------------------------- |
| color           | HexColor | 是   |        | tab 上的文字默认颜色                                         |                                                      |
| selectedColor   | HexColor | 是   |        | tab 上的文字选中时的颜色                                     |                                                      |
| backgroundColor | HexColor | 是   |        | tab 的背景色                                                 |                                                      |
| borderStyle     | String   | 否   | black  | tabbar 上边框的颜色，可选值 black/white，也支持其他颜色值    | App 2.3.4+ 、H5 3.0.0+                               |
| blurEffect      | String   | 否   | none   | iOS 高斯模糊效果，可选值 dark/extralight/light/none（参考:[使用说明 (opens new window)](https://ask.dcloud.net.cn/article/36617)） | App 2.4.0+ 支持、H5 3.0.0+（只有最新版浏览器才支持） |
| list            | Array    | 是   |        | tab 的列表，详见 list 属性说明，最少2个、最多5个 tab         |                                                      |
| position        | String   | 否   | bottom | 可选值 bottom、top                                           | top 值仅微信小程序支持                               |
| fontSize        | String   | 否   | 10px   | 文字默认大小                                                 | App 2.3.4+、H5 3.0.0+                                |
| iconWidth       | String   | 否   | 24px   | 图标默认宽度（高度等比例缩放）                               | App 2.3.4+、H5 3.0.0+                                |
| spacing         | String   | 否   | 3px    | 图标和文字的间距                                             | App 2.3.4+、H5 3.0.0+                                |
| height          | String   | 否   | 50px   | tabBar 默认高度                                              | App 2.3.4+、H5 3.0.0+                                |
| midButton       | Object   | 否   |        | 中间按钮 仅在 list 项为偶数时有效                            | App 2.3.4+、H5 3.0.0+                                |

其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下：

| 属性             | 类型    | 必填 | 说明                                                         | 平台差异                    |
| :--------------- | :------ | :--- | :----------------------------------------------------------- | :-------------------------- |
| pagePath         | String  | 是   | 页面路径，必须在 pages 中先定义                              |                             |
| text             | String  | 是   | tab 上按钮文字，在 App 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标 |                             |
| iconPath         | String  | 否   | 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 position 为 top 时，此参数无效，不支持网络图片，不支持字体图标 |                             |
| selectedIconPath | String  | 否   | 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 position 为 top 时，此参数无效 |                             |
| visible          | Boolean | 否   | 该项是否显示，默认显示                                       | App (3.2.10+)、H5 (3.2.10)+ |
| iconfont         | Object  | 否   | 字体图标，优先级高于 iconPath                                | App（3.4.4+）               |

**midButton 属性说明**

| 属性            | 类型   | 必填 | 默认值 | 描述                                                         |
| :-------------- | :----- | :--- | :----- | :----------------------------------------------------------- |
| width           | String | 否   | 80px   | 中间按钮的宽度，tabBar 其它项为减去此宽度后平分，默认值为与其它项平分宽度 |
| height          | String | 否   | 50px   | 中间按钮的高度，可以大于 tabBar 高度，达到中间凸起的效果     |
| text            | String | 否   |        | 中间按钮的文字                                               |
| iconPath        | String | 否   |        | 中间按钮的图片路径                                           |
| iconWidth       | String | 否   | 24px   | 图片宽度（高度等比例缩放）                                   |
| backgroundImage | String | 否   |        | 中间按钮的背景图片路径                                       |
| iconfont        | Object | 否   |        | 字体图标，优先级高于 iconPath                                |

**示例：**

```json
"tabBar":{
		// 文字颜色
		"color": "#b22",
		// 选中文字颜色
		"selectedColor": "#41a863",
		// 背景色
		"backgroundColor": "#fffae8",
		// tabBar位置 top只对小程序有效
		"position": "top",
		"list": [
			{
				// 名称
				"text": "首页", 
				// 页面路径
				"pagePath": "pages/index/index",
				// 图标
				"iconPath": "static/tabs/home.png",
				// 选中图标
				"selectedIconPath": "static/tabs/home-active.png"
			},
			{
				"text": "信息",
				"pagePath": "pages/message/message",
				"iconPath": "static/tabs/message.png",
				"selectedIconPath": "static/tabs/message-active.png"
			},
			{
				"text": "我们",
				"pagePath": "pages/contact/contact",
				"iconPath": "static/tabs/contact.png",
				"selectedIconPath": "static/tabs/contact-active.png"
			}
		]
	}
```

### 启动模式

利用`condition`增加启动模式

启动模式配置，仅开发期间生效，用于模拟直达页面的场景，如：小程序转发后，用户点击所打开的页面。

**属性说明：**

| 属性    | 类型   | 是否必填 | 描述                             |
| :------ | :----- | :------- | :------------------------------- |
| current | Number | 是       | 当前激活的模式，list节点的索引值 |
| list    | Array  | 是       | 启动模式列表                     |

**list说明：**

| 属性  | 类型   | 是否必填 | 描述                                                         |
| :---- | :----- | :------- | :----------------------------------------------------------- |
| name  | String | 是       | 启动模式名称                                                 |
| path  | String | 是       | 启动页面路径                                                 |
| query | String | 否       | 启动参数，可在页面的 [onLoad](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle) 函数里获得 |

**注意：** 在 App 里真机运行可直接打开配置的页面，微信开发者工具里需要手动改变编译模式，如下：

```json
"condition": {
    // 当前启动模式list下标
	"current": 0,
    // 启动模式list
	"list": [
		{	
            // 名称
			"name": "详情页",
            // 页面路径
			"path": "pages/detail/detail",
            // 携带参数
			"query": "123"
		}
	]
}
```

![image-20220920142228716](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20220920142228716.png)

## 自建组件

生命周期、注册组件、传参**和vue2一致！！** 也可以不注册组件使用，直接写标签

**uni.$emit(eventName,OBJECT)**：

触发全局的自定义事件，附加参数都会传给监听器回调函数。

| 属性      | 类型   | 描述                   |
| --------- | ------ | ---------------------- |
| eventName | String | 事件名                 |
| OBJECT    | Object | 触发事件携带的附加参数 |

**uni.$on(eventName,callback)**：

监听全局的自定义事件，事件由 `uni.$emit` 触发，回调函数会接收事件触发函数的传入参数。

| 属性      | 类型     | 描述           |
| --------- | -------- | -------------- |
| eventName | String   | 事件名         |
| callback  | Function | 事件的回调函数 |

**uni.$once(eventName,callback)**：

监听全局的自定义事件，事件由 `uni.$emit` 触发，但仅触发一次，在第一次触发之后移除该监听器。

| 属性      | 类型     | 描述           |
| --------- | -------- | -------------- |
| eventName | String   | 事件名         |
| callback  | Function | 事件的回调函数 |

**uni.$off([eventName, callback])**：

移除全局自定义事件监听器。

| 属性      | 类型          | 描述           |
| --------- | ------------- | -------------- |
| eventName | Array，String | 事件名         |
| callback  | Function      | 事件的回调函数 |

**Tips**

- 如果uni.$off没有传入参数，则移除App级别的所有事件监听器；
- 如果只提供了事件名（eventName），则移除该事件名对应的所有监听器；
- 如果同时提供了事件与回调，则只移除这个事件回调的监听器；
- 提供的回调必须跟$on的回调为同一个才能移除这个回调的监听器；

## 内置组件

### text

文本组件。

用于包裹文本内容。

**属性说明**

| 属性名      | 类型    | 默认值 | 说明         | 平台差异说明        |
| :---------- | :------ | :----- | :----------- | :------------------ |
| selectable  | Boolean | false  | 文本是否可选 | App、H5、快手小程序 |
| user-select | Boolean | false  | 文本是否可选 | 微信小程序          |
| space       | String  |        | 显示连续空格 | App、H5、微信小程序 |
| decode      | Boolean | false  | 是否解码     | App、H5、微信小程序 |

**space 值说明**

| 值   | 说明                   |
| :--- | :--------------------- |
| ensp | 中文字符空格一半大小   |
| emsp | 中文字符空格大小       |
| nbsp | 根据字体设置的空格大小 |

**Tips**

- `<text>` 组件内只支持嵌套 `<text>`，不支持其它组件或自定义组件，否则会引发在不同平台的渲染差异。
- 在app-nvue下，只有`<text>`才能包裹文本内容。无法在`<view>`组件包裹文本。
- decode 可以解析的有 ![image-20220920183430871](https://yang-cloud-img.oss-cn-beijing.aliyuncs.com/img/image-20220920183430871.png)
- 各个操作系统的空格标准并不一致。
- 除了文本节点以外的其他节点都无法长按选中。
- 支持 `\n` 方式换行。
- 如果使用 `<span>` 组件编译时会被转换为 `<text>`。

### view

视图容器。

它类似于传统html中的div，用于包裹各种元素内容。

如果使用[nvue (opens new window)](https://uniapp.dcloud.io/tutorial/nvue-outline)，则需注意，包裹文字应该使用`<text>`组件。

**属性说明**

| 属性名                 | 类型    | 默认值 | 说明                                                         |
| :--------------------- | :------ | :----- | :----------------------------------------------------------- |
| hover-class            | String  | none   | 指定按下去的样式类。当 hover-class="none" 时，没有点击态效果 |
| hover-stop-propagation | Boolean | false  | 指定是否阻止本节点的祖先节点出现点击态，App、H5、支付宝小程序、百度小程序不支持（支付宝小程序、百度小程序文档中都有此属性，实测未支持） |
| hover-start-time       | Number  | 50     | 按住后多久出现点击态，单位毫秒                               |
| hover-stay-time        | Number  | 400    | 手指松开后点击态保留时间，单位毫秒                           |

### button

按钮。

**属性说明**

| 属性名                 | 类型    | 默认值       | 说明                                                         | 生效时机                       | 平台差异说明                                             |
| :--------------------- | :------ | :----------- | :----------------------------------------------------------- | :----------------------------- | :------------------------------------------------------- |
| size                   | String  | default      | 按钮的大小                                                   |                                |                                                          |
| type                   | String  | default      | 按钮的样式类型                                               |                                |                                                          |
| plain                  | Boolean | false        | 按钮是否镂空，背景色透明                                     |                                |                                                          |
| disabled               | Boolean | false        | 是否禁用                                                     |                                |                                                          |
| loading                | Boolean | false        | 名称前是否带 loading 图标                                    |                                | H5、App(App-nvue 平台，在 ios 上为雪花，Android上为圆圈) |
| form-type              | String  |              | 用于 `<form>` 组件，点击分别会触发 `<form>` 组件的 submit/reset 事件 |                                |                                                          |
| open-type              | String  |              | 开放能力                                                     |                                |                                                          |
| hover-class            | String  | button-hover | 指定按钮按下去的样式类。当 hover-class="none" 时，没有点击态效果 |                                | App-nvue 平台暂不支持                                    |
| hover-start-time       | Number  | 20           | 按住后多久出现点击态，单位毫秒                               |                                |                                                          |
| hover-stay-time        | Number  | 70           | 手指松开后点击态保留时间，单位毫秒                           |                                |                                                          |
| app-parameter          | String  |              | 打开 APP 时，向 APP 传递的参数，open-type=launchApp时有效    |                                | 微信小程序、QQ小程序                                     |
| hover-stop-propagation | boolean | false        | 指定是否阻止本节点的祖先节点出现点击态                       |                                | 微信小程序                                               |
| lang                   | string  | 'en'         | 指定返回用户信息的语言，zh_CN 简体中文，zh_TW 繁体中文，en 英文。 |                                | 微信小程序                                               |
| session-from           | string  |              | 会话来源，open-type="contact"时有效                          |                                | 微信小程序                                               |
| send-message-title     | string  | 当前标题     | 会话内消息卡片标题，open-type="contact"时有效                |                                | 微信小程序                                               |
| send-message-path      | string  | 当前分享路径 | 会话内消息卡片点击跳转小程序路径，open-type="contact"时有效  |                                | 微信小程序                                               |
| send-message-img       | string  | 截图         | 会话内消息卡片图片，open-type="contact"时有效                |                                | 微信小程序                                               |
| show-message-card      | boolean | false        | 是否显示会话内消息卡片，设置此参数为 true，用户进入客服会话会在右下角显示"可能要发送的小程序"提示，用户点击后可以快速发送小程序消息，open-type="contact"时有效 |                                | 微信小程序                                               |
| group-id               | String  |              | 打开群资料卡时，传递的群号                                   | open-type="openGroupProfile"   | QQ小程序                                                 |
| guild-id               | String  |              | 打开频道页面时，传递的频道号                                 | open-type="openGuildProfile"   | QQ小程序                                                 |
| public-id              | String  |              | 打开公众号资料卡时，传递的号码                               | open-type="openPublicProfile"  | QQ小程序                                                 |
| @getphonenumber        | Handler |              | 获取用户手机号回调                                           | open-type="getPhoneNumber"     | 微信、支付宝、百度、字节、快手、京东小程序               |
| @getuserinfo           | Handler |              | 用户点击该按钮时，会返回获取到的用户信息，从返回参数的detail中获取到的值同uni.getUserInfo | open-type="getUserInfo"        | 微信、QQ、百度、快手、京东小程序                         |
| @error                 | Handler |              | 当使用开放能力时，发生错误的回调                             | open-type="launchApp"          | 微信、QQ、快手、京东小程序                               |
| @opensetting           | Handler |              | 在打开授权设置页并关闭后回调                                 | open-type="openSetting"        | 微信、QQ、百度、快手、京东小程序                         |
| @launchapp             | Handler |              | 从小程序打开 App 成功的回调                                  | open-type="launchApp"          | 微信、QQ、快手、京东小程序                               |
| @contact               | Handler |              | 客服消息回调                                                 | open-type="contact"            | 微信、QQ、百度、快手小程序                               |
| @chooseavatar          | Handler |              | 获取用户头像回调                                             | open-type="chooseAvatar"       | 微信小程序                                               |
| @addgroupapp           | Handler |              | 添加群应用的回调                                             | open-type="addGroupApp"        | QQ小程序                                                 |
| @chooseaddress         | Handler |              | 调起用户编辑并选择收货地址的回调                             | open-type="chooseAddress"      | 百度小程序                                               |
| @chooseinvoicetitle    | Handler |              | 用户选择发票抬头的回调                                       | open-type="chooseInvoiceTitle" | 百度小程序                                               |
| @subscribe             | Handler |              | 订阅消息授权回调                                             | open-type="subscribe"          | 百度小程序                                               |
| @login                 | Handler |              | 登录回调                                                     | open-type="login"              | 百度小程序                                               |

- **注1：`button-hover` 默认为 `{background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}`**
- `open-type="launchApp"`时需要调起的APP接入微信OpenSDK[详见(opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)

[#](https://uniapp.dcloud.net.cn/component/button.html#size-有效值)size 有效值

| 值      | 说明     |
| :------ | :------- |
| default | 默认大小 |
| mini    | 小尺寸   |

[#](https://uniapp.dcloud.net.cn/component/button.html#type-有效值)type 有效值

| 值      | 说明                                                         |
| :------ | :----------------------------------------------------------- |
| primary | 微信小程序、360小程序为绿色，App、H5、百度小程序、支付宝小程序、飞书小程序、快应用为蓝色，字节跳动小程序为红色，QQ小程序为浅蓝色。如想在多端统一颜色，请改用default，然后自行写样式 |
| default | 白色                                                         |
| warn    | 红色                                                         |

[#](https://uniapp.dcloud.net.cn/component/button.html#form-type-有效值)form-type 有效值

| 值     | 说明     |
| :----- | :------- |
| submit | 提交表单 |
| reset  | 重置表单 |

[#](https://uniapp.dcloud.net.cn/component/button.html#open-type-有效值)open-type 有效值

| 值                   | 说明                                                         | 平台差异说明                                                 |
| :------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| feedback             | 打开“意见反馈”页面，用户可提交反馈内容并上传日志             | App、微信小程序、QQ小程序                                    |
| share                | 触发用户转发                                                 | 微信小程序、百度小程序、支付宝小程序、字节跳动小程序、飞书小程序、QQ小程序、快手小程序、京东小程序、360小程序 |
| getUserInfo          | 获取用户信息，可以从@getuserinfo回调中获取到用户信息         | 微信小程序、百度小程序、QQ小程序、快手小程序、京东小程序、360小程序 |
| contact              | 打开客服会话，如果用户在会话中点击消息卡片后返回应用，可以从 @contact 回调中获得具体信息 | 微信小程序、百度小程序、快手小程序                           |
| getPhoneNumber       | 获取用户手机号，可以从@getphonenumber回调中获取到用户信息    | 微信小程序、百度小程序、字节跳动小程序、支付宝小程序、快手小程序、京东小程序。App平台另见[一键登陆(opens new window)](https://uniapp.dcloud.net.cn/univerify) |
| launchApp            | 小程序中打开APP，可以通过app-parameter属性设定向APP传的参数  | [微信小程序 (opens new window)](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/launchApp.html)、[QQ小程序 (opens new window)](https://q.qq.com/wiki/develop/miniprogram/frame/open_ability/open_app.html)、快手小程序、京东小程序 |
| openSetting          | 打开授权设置页                                               | 微信小程序、QQ小程序、百度小程序、快手小程序、京东小程序、360小程序 |
| chooseAvatar         | 获取用户头像，可以从@chooseavatar回调中获取到头像信息        | 微信小程序2.21.2版本+                                        |
| uploadDouyinVideo    | 发布抖音视频                                                 | 字节小程序2.65.0版本+                                        |
| getAuthorize         | 支持小程序授权                                               | 支付宝小程序                                                 |
| lifestyle            | 关注生活号                                                   | 支付宝小程序                                                 |
| contactShare         | 分享到通讯录好友                                             | 支付宝小程序基础库1.11.0版本+                                |
| openGroupProfile     | 呼起QQ群资料卡页面，可以通过group-id属性设定需要打开的群资料卡的群号，同时manifest.json中必须配置groupIdList | QQ小程序基础库1.4.7版本+                                     |
| openGuildProfile     | 呼起频道页面，可以通过guild-id属性设定需要打开的频道ID       | QQ小程序基础库1.46.8版本+                                    |
| openPublicProfile    | 打开公众号资料卡，可以通过public-id属性设定需要打开的公众号资料卡的号码，同时manifest.json中必须配置publicIdList | QQ小程序基础库1.12.0版本+                                    |
| shareMessageToFriend | 在自定义开放数据域组件中,向指定好友发起分享据                | QQ小程序基础库1.17.0版本+                                    |
| addFriend            | 添加好友， 对方需要通过该小程序进行授权，允许被加好友后才能调用成功用户授权 | QQ小程序                                                     |
| addColorSign         | 添加彩签，点击后添加状态有用户提示，无回调                   | QQ小程序基础库1.10.0版本+                                    |
| addGroupApp          | 添加群应用（只有管理员或群主有权操作），添加后给button绑定@addgroupapp事件接收回调数据 | QQ小程序基础库1.16.0版本+                                    |
| addToFavorites       | 收藏当前页面，点击按钮后会触发Page.onAddToFavorites方法      | QQ小程序基础库1.19.0版本+                                    |
| chooseAddress        | 选择用户收货地址，可以从@chooseaddress回调中获取到用户选择的地址信息 | 百度小程序3.160.3版本+                                       |
| chooseInvoiceTitle   | 选择用户发票抬头，可以从@chooseinvoicetitle回调中获取到用户选择发票抬头信息 | 百度小程序3.160.3版本+                                       |
| login                | 登录，可以从@login回调中确认是否登录成功                     | 百度小程序3.230.1版本+                                       |
| subscribe            | 订阅类模板消息，需要用户授权才可发送                         | 百度小程序                                                   |
| favorite             | 触发用户收藏                                                 | 快手小程序                                                   |
| watchLater           | 触发用户稍后再看                                             | 快手小程序                                                   |
| openProfile          | 触发打开用户主页                                             | 快手小程序                                                   |

[#](https://uniapp.dcloud.net.cn/component/button.html#feedback)feedback

open-type 为 feedback时：

- 小程序中，开发者可以登录 [微信小程序管理后台 (opens new window)](https://mp.weixin.qq.com/)、[QQ小程序后台 (opens new window)](https://q.qq.com/#/)后，进入菜单“客服反馈”页面获取反馈内容。
- 在 App 中，开发者登录 [DCloud开发者中心 (opens new window)](https://dev.dcloud.net.cn/)后点击应用名称，进入左侧菜单“用户反馈”页面获取反馈内容。
- 但推荐使用全端的、开源的、云端一体的意见反馈功能，[前端部分 (opens new window)](https://ext.dcloud.net.cn/plugin?id=50)、[管理端部分](https://ext.dcloud.net.cn/plugin?id=4992)

### image

图片。

| 属性名                 | 类型        | 默认值        | 说明                                                         | 平台差异说明                                       |
| :--------------------- | :---------- | :------------ | :----------------------------------------------------------- | :------------------------------------------------- |
| src                    | String      |               | 图片资源地址                                                 |                                                    |
| mode                   | String      | 'scaleToFill' | 图片裁剪、缩放的模式                                         |                                                    |
| lazy-load              | Boolean     | false         | 图片懒加载。只针对page与scroll-view下的image有效             | 微信小程序、百度小程序、字节跳动小程序、飞书小程序 |
| fade-show              | Boolean     | true          | 图片显示动画效果                                             | 仅App-nvue 2.3.4+ Android有效                      |
| webp                   | boolean     | false         | 在系统不支持webp的情况下是否单独启用webp。默认false，只支持网络资源。webp支持详见下面说明 | 微信小程序2.9.0                                    |
| show-menu-by-longpress | boolean     | false         | 开启长按图片显示识别小程序码菜单                             | 微信小程序2.7.0                                    |
| draggable              | boolean     | true          | 是否能拖动图片                                               | H5 3.1.1+、App（iOS15+）                           |
| @error                 | HandleEvent |               | 当错误发生时，发布到 AppService 的事件名，事件对象event.detail = {errMsg: 'something wrong'} |                                                    |
| @load                  | HandleEvent |               | 当图片载入完毕时，发布到 AppService 的事件名，事件对象event.detail = {height:'图片高度px', width:'图片宽度px'} |                                                    |

**Tips**

- `<image>` 组件默认宽度 320px、高度 240px；`app-nvue平台，暂时默认为屏幕宽度、高度 240px；`
- `src` 仅支持相对路径、绝对路径，支持 base64 码；
- 页面结构复杂，css样式太多的情况，使用 image 可能导致样式生效较慢，出现 “闪一下” 的情况，此时设置 `image{will-change: transform}` ,可优化此问题。
- 自定义组件里面使用 `<image>`时，若 `src` 使用相对路径可能出现路径查找失败的情况，故建议使用绝对路径。
- svg 格式的图片在不同的平台支持情况不同。具体为：app-nvue 不支持 svg 格式的图片，小程序上只支持网络地址。
- webp图片支持详解
  - Android4以上（含）、iOS14以上（含）系统内置支持webp，此时，不管web、小程序、app，也不管vue还是nvue都可以直接使用webp；
  - iOS14以下，app-vue下，iOS不支持；app-nvue下，iOS支持；微信小程序2.9.0起，配置属性webp为true时iOS支持；
  - pc浏览器上，webp在不同浏览器的支持详见：[https://caniuse.com/?search=webp(opens new window)](https://caniuse.com/?search=webp)

**mode 有效值：**

mode 有 14 种模式，其中 5 种是缩放模式，9 种是裁剪模式。

| 模式 | 值           | 说明                                                         |
| :--- | :----------- | :----------------------------------------------------------- |
| 缩放 | scaleToFill  | 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素  |
| 缩放 | aspectFit    | 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 |
| 缩放 | aspectFill   | 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 |
| 缩放 | widthFix     | 宽度不变，高度自动变化，保持原图宽高比不变                   |
| 缩放 | heightFix    | 高度不变，宽度自动变化，保持原图宽高比不变 **App 和 H5 平台 HBuilderX 2.9.3+ 支持、微信小程序需要基础库 2.10.3** |
| 裁剪 | top          | 不缩放图片，只显示图片的顶部区域                             |
| 裁剪 | bottom       | 不缩放图片，只显示图片的底部区域                             |
| 裁剪 | center       | 不缩放图片，只显示图片的中间区域                             |
| 裁剪 | left         | 不缩放图片，只显示图片的左边区域                             |
| 裁剪 | right        | 不缩放图片，只显示图片的右边区域                             |
| 裁剪 | top left     | 不缩放图片，只显示图片的左上边区域                           |
| 裁剪 | top right    | 不缩放图片，只显示图片的右上边区域                           |
| 裁剪 | bottom left  | 不缩放图片，只显示图片的左下边区域                           |
| 裁剪 | bottom right | 不缩放图片，只显示图片的右下边区域                           |

### rich-text

渲染富文本得

属性：

- nodes  需要渲染得HTML字符串



### radio

单选项目。

**属性说明**

| 属性名   | 类型    | 默认值 | 说明                                                         |
| :------- | :------ | :----- | :----------------------------------------------------------- |
| value    | String  |        | `<radio>` 标识。当该 `<radio>` 选中时，`<radio-group>` 的 change 事件会携带 `<radio>` 的 value |
| checked  | Boolean | false  | 当前是否选中                                                 |
| disabled | Boolean | false  | 是否禁用                                                     |
| color    | Color   |        | radio的颜色，同css的color                                    |

### uni-number-box

带加减按钮的数字输入框。

属性：

|    属性名     |  类型   | 默认值 |          说明          |
| :-----------: | :-----: | :----: | :--------------------: |
| value/v-model | Number  |   0    |      输入框当前值      |
|      min      | Number  |   0    |         最小值         |
|      max      | Number  |  100   |         最大值         |
|     step      | Number  |   1    | 每次点击改变的间隔大小 |
|   disabled    | Boolean | false  |     是否为禁用状态     |

事件：

| 事件名称 |                        说明                        | 返回值 |
| :------: | :------------------------------------------------: | :----: |
|  change  | 输入框值改变时触发的事件，参数为输入框当前的 value |   -    |
|  focus   |     输入框聚焦时触发的事件，参数为 event 对象      |   -    |
|   blur   |     输入框失焦时触发的事件，参数为 event 对象      |   -    |

## uni常用API

| API               | 说明                                     |
| ----------------- | ---------------------------------------- |
| getSystemInfoSync | 获取当前设备信息，分为同步获取和异步获取 |
|                   |                                          |
|                   |                                          |



## 样式

### rpx

rpx 即响应式 px，一种根据屏幕宽度自适应的动态单位。以 750 宽的屏幕为基准，750rpx 恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大，但在 App（vue2 不含 nvue） 端和 H5（vue2） 端屏幕宽度达到 960px 时，默认将按照 375px 的屏幕宽度进行计算

设计师在提供设计图时，一般只提供一个分辨率的图。



严格按设计图标注的 px 做开发，在不同宽度的手机上界面很容易变形。

而且主要是宽度变形。高度一般因为有滚动条，不容易出问题。由此，引发了较强的动态宽度单位需求。

微信小程序设计了 rpx 解决这个问题。`uni-app` 在 App 端、H5 端都支持了 `rpx`，并且可以配置不同屏幕宽度的计算方式



开发者可以通过设计稿基准宽度计算页面元素 rpx 值，设计稿 1px 与框架样式 1rpx 转换公式如下：

```
设计稿 1px / 设计稿基准宽度 = 框架样式 1rpx / 750rpx
```

换言之，页面元素宽度在 `uni-app` 中的宽度计算公式：

```
750 * 元素在设计稿中的宽度 / 设计稿基准宽度
```

**举例说明：**

1. 若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 `uni-app` 里面的宽度应该设为：`750 * 100 / 750`，结果为：100rpx。
2. 若设计稿宽度为 640px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 `uni-app` 里面的宽度应该设为：`750 * 100 / 640`，结果为：117rpx。
3. 若设计稿宽度为 375px，元素 B 在设计稿上的宽度为 200px，那么元素 B 在 `uni-app` 里面的宽度应该设为：`750 * 200 / 375`，结果为：400rpx。

### 局部样式和全局样式

- 页面css为`局部样式`
- `@/uni.scss``为全局样式`
- 局部样式会把全局样式覆盖

### 样式导入

使用`@import`语句可以导入外联样式表，`@import`后跟需要导入的外联样式表的相对路径，用`;`表示语句结束。

**示例代码：**

```html
<style>
    @import "../../common/uni.css";

    .uni-card {
        box-shadow: none;
    }
</style>
```

### 字体图标

`uni-app` 支持使用字体图标，使用方式与普通 `web` 项目相同

使用本地路径图标字体需注意：

1. 为方便开发者，在字体文件小于 40kb 时，`uni-app` 会自动将其转化为 base64 格式；
2. 字体文件大于等于 40kb，仍转换为 base64 方式使用的话可能有性能问题，如开发者必须使用，则需自己将其转换为 base64 格式使用，或将其挪到服务器上，从网络地址引用；
3. 字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。

```css
@font-face {
	font-family: test1-icon;
	src: url('~@/static/iconfont.ttf');
}
```

## 生命周期

### 应用生命周期

> 整个应用的生命周期

在`@/App.vue`

| 函数名   | 说明                                           |
| :------- | :--------------------------------------------- |
| onLaunch | 当`uni-app` 初始化完成时触发（全局只触发一次） |
| onShow   | 当 `uni-app` 启动，或从后台进入前台显示        |
| onHide   | 当 `uni-app` 从前台进入后台                    |
| onError  | 当 `uni-app` 报错时触发，有一个形参：错误信息  |

举例：

```vue
<script>
	export default {
		onLaunch: function() {
			console.log('App Launch')
		},
		onShow: function() {
			console.log('App Show')
		},
		onHide: function() {
			console.log('App Hide')
		},
		onError: function(err) {
			console.log(err)
		}
	}
</script>
```

### 页面生命周期

`uni-app` 支持如下页面生命周期函数：

写在页面vue文件的对象中

| 函数名                              | 说明                                                         | 平台差异说明                                                 | 最低版本 |
| :---------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------- |
| onInit                              | 监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad | 百度小程序                                                   | 3.1.0+   |
| onLoad                              | 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考[示例](https://uniapp.dcloud.net.cn/api/router#navigateto) |                                                              |          |
| onShow                              | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |                                                              |          |
| onReady                             | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 |                                                              |          |
| onHide                              | 监听页面隐藏                                                 |                                                              |          |
| onUnload                            | 监听页面卸载                                                 |                                                              |          |
| onResize                            | 监听窗口尺寸变化                                             | App、微信小程序、快手小程序                                  |          |
| onPullDownRefresh                   | 监听用户下拉动作，一般用于下拉刷新，参考[示例](https://uniapp.dcloud.net.cn/api/ui/pulldown) |                                                              |          |
| onReachBottom                       | 页面滚动到底部的事件（不是scroll-view滚到底），常用于下拉下一页数据。默认距离50px触发，可在pages.json修改 |                                                              |          |
| onTabItemTap                        | 点击 tab 时触发，参数为Object，具体见下方注意事项            | 微信小程序、QQ小程序、支付宝小程序、百度小程序、H5、App、快手小程序、京东小程序 |          |
| onShareAppMessage                   | 用户点击右上角分享                                           | 微信小程序、QQ小程序、支付宝小程序、字节小程序、飞书小程序、快手小程序、京东小程序 |          |
| onPageScroll                        | 监听页面滚动，参数为Object                                   | nvue暂不支持                                                 |          |
| onNavigationBarButtonTap            | 监听原生标题栏按钮点击事件，参数为Object                     | App、H5                                                      |          |
| onBackPress                         | 监听页面返回，返回 event = {from:backbutton、 navigateBack} ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：[onBackPress 详解 (opens new window)](http://ask.dcloud.net.cn/article/35120)。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。 | app、H5、支付宝小程序                                        |          |
| onNavigationBarSearchInputChanged   | 监听原生标题栏搜索输入框输入内容变化事件                     | App、H5                                                      | 1.6.0    |
| onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 | App、H5                                                      | 1.6.0    |
| onNavigationBarSearchInputClicked   | 监听原生标题栏搜索输入框点击事件（pages.json 中的 searchInput 配置 disabled 为 true 时才会触发） | App、H5                                                      | 1.6.0    |
| onShareTimeline                     | 监听用户点击右上角转发到朋友圈                               | 微信小程序                                                   | 2.8.1+   |
| onAddToFavorites                    | 监听用户点击右上角收藏                                       | 微信小程序                                                   | 2.8.1+   |

`onInit`使用注意

- 仅百度小程序基础库 3.260 以上支持 onInit 生命周期
- 其他版本或平台可以同时使用 onLoad 生命周期进行兼容，注意避免重复执行相同逻辑
- 不依赖页面传参的逻辑可以直接使用 created 生命周期替代

举例：

```vue
<script>
export default {

	onLoad() {
		console.log('首页初始化了')
	},
	onReady() {
		console.log('首页渲染完成了')
	},
	onHide() {
		console.log('首页隐藏了')
	},
	onShow() {
		console.log('首页显示了')
	},
	onUnload() {
		console.log('首页卸载了');
	},
	onPullDownRefresh() {
		console.log('下拉刷新了');
		setTimeout(() => {
			console.log('完成');
			// 停止下拉刷新状态
			uni.stopPullDownRefresh();
		},2000)
	},
	onReachBottom() {
		console.log('到底了');
	}
};
</script>
```

## 发起请求

使用方法 `uni.request(OBJECT)`

发起网络请求。

> 在各个小程序平台运行时，网络相关的 API 在使用前需要配置域名白名单。

**OBJECT 参数说明**

| 参数名          | 类型                      | 必填 | 默认值 | 说明                                               | 平台差异说明                                                 |
| :-------------- | :------------------------ | :--- | :----- | :------------------------------------------------- | :----------------------------------------------------------- |
| url             | String                    | 是   |        | 开发者服务器接口地址                               |                                                              |
| data            | Object/String/ArrayBuffer | 否   |        | 请求的参数                                         | App 3.3.7 以下不支持 ArrayBuffer 类型                        |
| header          | Object                    | 否   |        | 设置请求的 header，header 中不能设置 Referer。     | App、H5端会自动带上cookie，且H5端不可手动修改                |
| method          | String                    | 否   | GET    | 有效值详见下方说明                                 |                                                              |
| timeout         | Number                    | 否   | 60000  | 超时时间，单位 ms                                  | H5(HBuilderX 2.9.9+)、APP(HBuilderX 2.9.9+)、微信小程序（2.10.0）、支付宝小程序 |
| dataType        | String                    | 否   | json   | 如果设为 json，会尝试对返回的数据做一次 JSON.parse |                                                              |
| responseType    | String                    | 否   | text   | 设置响应的数据类型。合法值：text、arraybuffer      | 支付宝小程序不支持                                           |
| sslVerify       | Boolean                   | 否   | true   | 验证 ssl 证书                                      | 仅App安卓端支持（HBuilderX 2.3.3+），不支持离线打包          |
| withCredentials | Boolean                   | 否   | false  | 跨域请求时是否携带凭证（cookies）                  | 仅H5支持（HBuilderX 2.6.15+）                                |
| firstIpv4       | Boolean                   | 否   | false  | DNS解析时优先使用ipv4                              | 仅 App-Android 支持 (HBuilderX 2.8.0+)                       |
| success         | Function                  | 否   |        | 收到开发者服务器成功返回的回调函数                 |                                                              |
| fail            | Function                  | 否   |        | 接口调用失败的回调函数                             |                                                              |
| complete        | Function                  | 否   |        | 接口调用结束的回调函数（调用成功、失败都会执行）   |                                                              |

**method 有效值**

注意：method有效值必须大写，每个平台支持的method有效值不同，详细见下表。

| method  | App  |  H5  | 微信小程序 | 支付宝小程序 | 百度小程序 | 字节跳动小程序、飞书小程序 | 快手小程序 | 京东小程序 |
| :-----: | :--: | :--: | :--------: | :----------: | :--------: | :------------------------: | :--------: | :--------: |
|   GET   |  √   |  √   |     √      |      √       |     √      |             √              |     √      |     √      |
|  POST   |  √   |  √   |     √      |      √       |     √      |             √              |     √      |     √      |
|   PUT   |  √   |  √   |     √      |      x       |     √      |             √              |     x      |     x      |
| DELETE  |  √   |  √   |     √      |      x       |     √      |             x              |     x      |     x      |
| CONNECT |  x   |  √   |     √      |      x       |     x      |             x              |     x      |     x      |
|  HEAD   |  x   |  √   |     √      |      x       |     √      |             x              |     x      |     x      |
| OPTIONS |  √   |  √   |     √      |      x       |     √      |             x              |     x      |     x      |
|  TRACE  |  x   |  √   |     √      |      x       |     x      |             x              |     x      |     x      |

**success 返回参数说明**

| 参数       | 类型                      | 说明                                         |
| :--------- | :------------------------ | :------------------------------------------- |
| data       | Object/String/ArrayBuffer | 开发者服务器返回的数据                       |
| statusCode | Number                    | 开发者服务器返回的 HTTP 状态码               |
| header     | Object                    | 开发者服务器返回的 HTTP Response Header      |
| cookies    | `Array.<string>`          | 开发者服务器返回的 cookies，格式为字符串数组 |

**data 数据说明**

最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String。转换规则如下：

- 对于 `GET` 方法，会将数据转换为 query string。例如 `{ name: 'name', age: 18 }` 转换后的结果是 `name=name&age=18`。
- 对于 `POST` 方法且 `header['content-type']` 为 `application/json` 的数据，会进行 JSON 序列化。
- 对于 `POST` 方法且 `header['content-type']` 为 `application/x-www-form-urlencoded` 的数据，会将数据转换为 query string。

**第三方插件**

@escook/request-miniprogram[@escook/request-miniprogram - npm (npmjs.com)](https://www.npmjs.com/package/@escook/request-miniprogram)

## 数据缓存

### uni.setStorage(OBJECT)

将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。

**OBJECT 参数说明**

| 参数名   | 类型     | 必填 | 说明                                                         |
| :------- | :------- | :--- | :----------------------------------------------------------- |
| key      | String   | 是   | 本地缓存中的指定的 key                                       |
| data     | Any      | 是   | 需要存储的内容，只支持原生类型、及能够通过 JSON.stringify 序列化的对象 |
| success  | Function | 否   | 接口调用成功的回调函数                                       |
| fail     | Function | 否   | 接口调用失败的回调函数                                       |
| complete | Function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）             |

```js
// 新增Storage
add() {
	uni.setStorage({
		key:'id',
		data:18,
		success(res){
			console.log(res);
		}
	})
},
```

### uni.getStorage(OBJECT)

从本地缓存中异步获取指定 key 对应的内容。

**OBJECT 参数说明**

| 参数名   | 类型     | 必填 | 说明                                             |
| :------- | :------- | :--- | :----------------------------------------------- |
| key      | String   | 是   | 本地缓存中的指定的 key                           |
| success  | Function | 是   | 接口调用的回调函数，res = {data: key对应的内容}  |
| fail     | Function | 否   | 接口调用失败的回调函数                           |
| complete | Function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

**success 返回参数说明**

| 参数 | 类型 | 说明           |
| :--- | :--- | :------------- |
| data | Any  | key 对应的内容 |

```js
// 获取Storage
get() {
	uni.getStorage({
		key:'id',
		success(res) {
			console.log(res.data);
		}
	})
}
```

### uni.removeStorage(OBJECT)

从本地缓存中异步移除指定 key。

**OBJECT 参数说明**

| 参数名   | 类型     | 必填 | 说明                                             |
| :------- | :------- | :--- | :----------------------------------------------- |
| key      | String   | 是   | 本地缓存中的指定的 key                           |
| success  | Function | 是   | 接口调用的回调函数                               |
| fail     | Function | 否   | 接口调用失败的回调函数                           |
| complete | Function | 否   | 接口调用结束的回调函数（调用成功、失败都会执行） |

```js
// 删除Storage
remove() {
	uni.removeStorage({
		key:'id',
		success(res) {
			console.log(res);
		}
	})
},
```

## 图片

### 图片上传

**uni.chooseImage(OBJECT)**

从本地相册选择图片或使用相机拍照。

App端如需要更丰富的相机拍照API（如直接调用前置摄像头），参考[plus.camera(opens new window)](https://www.html5plus.org/doc/zh_cn/camera.html)

**OBJECT 参数说明**

| 参数名     | 类型            | 必填 | 说明                                                         | 平台差异说明                              |
| :--------- | :-------------- | :--- | :----------------------------------------------------------- | :---------------------------------------- |
| count      | Number          | 否   | 最多可以选择的图片张数，默认9                                | 见下方说明                                |
| sizeType   | Array`<String>` | 否   | original 原图，compressed 压缩图，默认二者都有               | App、微信小程序、支付宝小程序、百度小程序 |
| extension  | Array`<String>` | 否   | 根据文件拓展名过滤，每一项都不能是空字符串。默认不过滤。     | H5(HBuilder X2.9.9+)                      |
| sourceType | Array`<String>` | 否   | album 从相册选图，camera 使用相机，默认二者都有。如需直接开相机或直接选相册，请只使用一个选项 |                                           |
| crop       | Object          | 否   | 图像裁剪参数，设置后 sizeType 失效                           | App 3.1.19+                               |
| success    | Function        | 是   | 成功则返回图片的本地文件路径列表 tempFilePaths               |                                           |
| fail       | Function        | 否   | 接口调用失败的回调函数                                       | 小程序、App                               |
| complete   | Function        | 否   | 接口调用结束的回调函数（调用成功、失败都会执行）             |                                           |

**Tips**

- count 值在 H5 平台的表现，基于浏览器本身的规范。目前测试的结果来看，只能限制单选/多选，并不能限制数量。并且，在实际的手机浏览器很少有能够支持多选的。
- sourceType 值在 H5 平台根据浏览器的不同而表现不同，一般不可限制仅使用相册，部分浏览器也无法限制是否使用相机。
- 可以通过用户授权API来判断用户是否给应用授予相册或摄像头的访问权限[https://uniapp.dcloud.io/api/other/authorize(opens new window)](https://uniapp.dcloud.io/api/other/authorize)
- App端如需选择非媒体文件，可在插件市场搜索[文件选择 (opens new window)](https://ext.dcloud.net.cn/search?q=文件选择)，其中Android端可以使用Native.js，无需原生插件，而iOS端需要原生插件。
- 选择照片大多为了上传，uni ui封装了更完善的[uni-file-picker组件 (opens new window)](https://ext.dcloud.net.cn/plugin?id=4079)，文件选择、上传到uniCloud的免费存储和cdn中，一站式集成。强烈推荐使用。

### 图片预览

**uni.previewImage(OBJECT)**

预览图片。

**OBJECT 参数说明**



| 参数名           | 类型            | 必填         | 说明                                                         | 平台差异说明 |
| :--------------- | :-------------- | :----------- | :----------------------------------------------------------- | :----------- |
| current          | String/Number   | 详见下方说明 | current 为当前显示图片的链接/索引值，不填或填写的值无效则为 urls 的第一张。**App平台在 1.9.5至1.9.8之间，current为必填。不填会报错** |              |
| urls             | Array`<String>` | 是           | 需要预览的图片链接列表                                       |              |
| indicator        | String          | 否           | 图片指示器样式，可取值："default" - 底部圆点指示器； "number" - 顶部数字指示器； "none" - 不显示指示器。 | App          |
| loop             | Boolean         | 否           | 是否可循环预览，默认值为 false                               | App          |
| longPressActions | Object          | 否           | 长按图片显示操作菜单，如不填默认为**保存相册**               | App 1.9.5+   |
| success          | Function        | 否           | 接口调用成功的回调函数                                       |              |
| fail             | Function        | 否           | 接口调用失败的回调函数                                       |              |
| complete         | Function        | 否           | 接口调用结束的回调函数（调用成功、失败都会执行）             |              |



## 条件编译

条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。

**写法：**以 #ifdef 或 #ifndef 加 **%PLATFORM%** 开头，以 #endif 结尾。

- \#ifdef：if defined 仅在某平台存在
- \#ifndef：if not defined 除了某平台均存在
- **%PLATFORM%**：平台名称

| 条件编译写法                                             | 说明                                                         |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| #ifdef **APP-PLUS** 需条件编译的代码 #endif              | 仅出现在 App 平台下的代码                                    |
| #ifndef **H5** 需条件编译的代码 #endif                   | 除了 H5 平台，其它平台均存在的代码                           |
| #ifdef **H5** \|\| **MP-WEIXIN** 需条件编译的代码 #endif | 在 H5 平台或微信小程序平台存在的代码（这里只有\|\|，不可能出现&&，因为没有交集） |

**%PLATFORM%** **可取值如下：**

| 值                      | 生效条件                                                     |
| :---------------------- | :----------------------------------------------------------- |
| VUE3                    | HBuilderX 3.2.0+ [详情(opens new window)](https://ask.dcloud.net.cn/article/37834) |
| APP-PLUS                | App                                                          |
| APP-PLUS-NVUE或APP-NVUE | App nvue 页面                                                |
| H5                      | H5                                                           |
| MP-WEIXIN               | 微信小程序                                                   |
| MP-ALIPAY               | 支付宝小程序                                                 |
| MP-BAIDU                | 百度小程序                                                   |
| MP-TOUTIAO              | 字节跳动小程序                                               |
| MP-LARK                 | 飞书小程序                                                   |
| MP-QQ                   | QQ小程序                                                     |
| MP-KUAISHOU             | 快手小程序                                                   |
| MP-JD                   | 京东小程序                                                   |
| MP-360                  | 360小程序                                                    |
| MP                      | 微信小程序/支付宝小程序/百度小程序/字节跳动小程序/飞书小程序/QQ小程序/360小程序 |
| QUICKAPP-WEBVIEW        | 快应用通用(包含联盟、华为)                                   |
| QUICKAPP-WEBVIEW-UNION  | 快应用联盟                                                   |
| QUICKAPP-WEBVIEW-HUAWEI | 快应用华为                                                   |

**支持的文件**

- .vue
- .js
- .css
- pages.json
- 各预编译语言文件，如：.scss、.less、.stylus、.ts、.pug

**注意：**

- 条件编译是利用注释实现的，在不同语法里注释写法不一样，js使用 `// 注释`、css 使用 `/* 注释 */`、vue/nvue 模板里使用 `<!-- 注释 -->`；
- 条件编译APP-PLUS包含APP-NVUE和APP-VUE，APP-PLUS-NVUE和APP-NVUE没什么区别，为了简写后面出了APP-NVUE ；
- 使用条件编译请保证`编译前`和`编译后`文件的正确性，比如json文件中不能有多余的逗号；
- `VUE3` 需要在项目的 `manifest.json` 文件根节点配置 `"vueVersion" : "3"`

## 页面跳转

### 组件式跳转

`navigator`

该组件类似HTML中的`<a>`组件，但只能跳转本地页面。目标页面必须在pages.json中注册。

该组件的功能有API方式，另见：[https://uniapp.dcloud.io/api/router?id=navigateto(opens new window)](https://uniapp.dcloud.io/api/router?id=navigateto)

**属性说明**

| 属性名                 | 类型    | 默认值          | 说明                                                         | 平台差异说明               |
| :--------------------- | :------ | :-------------- | :----------------------------------------------------------- | :------------------------- |
| url                    | String  |                 | 应用内的跳转链接，值为相对路径或绝对路径，如："../first/first"，"/pages/first/first"，注意不能加 `.vue` 后缀 |                            |
| open-type              | String  | navigate        | 跳转方式                                                     |                            |
| delta                  | Number  |                 | 当 open-type 为 'navigateBack' 时有效，表示回退的层数        |                            |
| animation-type         | String  | pop-in/out      | 当 open-type 为 navigate、navigateBack 时有效，窗口的显示/关闭动画效果，详见：[窗口动画](https://uniapp.dcloud.net.cn/api/router#animation) | App                        |
| animation-duration     | Number  | 300             | 当 open-type 为 navigate、navigateBack 时有效，窗口显示/关闭动画的持续时间。 | App                        |
| hover-class            | String  | navigator-hover | 指定点击时的样式类，当hover-class="none"时，没有点击态效果   |                            |
| hover-stop-propagation | Boolean | false           | 指定是否阻止本节点的祖先节点出现点击态                       | 微信小程序                 |
| hover-start-time       | Number  | 50              | 按住后多久出现点击态，单位毫秒                               |                            |
| hover-stay-time        | Number  | 600             | 手指松开后点击态保留时间，单位毫秒                           |                            |
| target                 | String  | self            | 在哪个小程序目标上发生跳转，默认当前小程序，值域self/miniProgram | 微信2.0.7+、百度2.5.2+、QQ |

**open-type 有效值**

| 值           | 说明                                   | 平台差异说明                     |
| :----------- | :------------------------------------- | :------------------------------- |
| navigate     | 对应 uni.navigateTo 的功能             |                                  |
| redirect     | 对应 uni.redirectTo 的功能             |                                  |
| switchTab    | 对应 uni.switchTab 的功能              |                                  |
| reLaunch     | 对应 uni.reLaunch 的功能               | 字节跳动小程序与飞书小程序不支持 |
| navigateBack | 对应 uni.navigateBack 的功能           |                                  |
| exit         | 退出小程序，target="miniProgram"时生效 | 微信2.1.0+、百度2.5.2+、QQ1.4.7+ |

**注意**

- 跳转tabbar页面，必须设置open-type="switchTab"
- navigator-hover 默认为 {background-color: rgba(0, 0, 0, 0.1); opacity: 0.7;}, `<navigator>` 的子节点背景色应为透明色。
- navigator-`open-type`属性 如果使用对应的值，则对应值的功能会高于对应跳转路径。
- app-nvue 平台只有纯nvue项目（render为native）才支持 `<navigator>`。非render为native的情况下，nvue暂不支持navigator组件，请使用API跳转。
- app下退出应用，Android平台可以使用[plus.runtime.quit (opens new window)](https://www.html5plus.org/doc/zh_cn/runtime.html#plus.runtime.quit)。iOS没有退出应用的概念。
- [uLink组件 (opens new window)](https://ext.dcloud.net.cn/plugin?id=1182)是navigator组件的增强版，样式上自带下划线，功能上支持打开在线网页、其他App的schema、mailto发邮件、tel打电话。

## 小程序分包

1）配置`manifest.json`配置开启分包

```json
"mp-weixin" : {
		"optimization":{"subPackages":true}
    },
```

2）根目录创建你`subpkg`目录

3）`pages.json`中增加`subPackages`对象，配置

- `root` 分包根目录   
- `pages` 分包页面数组

3）`subpkg`目录创建页面，**选择小程序分包**

